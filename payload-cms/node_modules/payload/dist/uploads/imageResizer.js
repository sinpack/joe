"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that does not need to be resized, a result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ const createImageName = (outputImageName, { height, width }, extension)=>`${outputImageName}-${width}x${height}.${extension}`;
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = ({ name, filename = null, filesize = null, height = null, mimeType = null, sizesToSave = [], width = null })=>{
    return {
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    };
};
/**
 * Check if the image needs to be resized according to the requested dimensions
 * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,
 * the image will be resized regardless of the requested dimensions, given that the
 * width or height to be resized is provided.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if resizing is not needed, false otherwise
 */ const preventResize = ({ height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }, original)=>{
    // default is to allow reduction
    if (withoutReduction !== undefined) {
        return false // needs resize
        ;
    }
    // default is to prevent enlargement
    if (withoutEnlargement !== undefined) {
        return false // needs resize
        ;
    }
    const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth;
    if (isWidthOrHeightNotDefined) {
        // If width and height are not defined, it means there is a format conversion
        // and the image needs to be "resized" (transformed).
        return false // needs resize
        ;
    }
    const hasInsufficientWidth = desiredWidth > original.width;
    const hasInsufficientHeight = desiredHeight > original.height;
    if (hasInsufficientWidth && hasInsufficientHeight) {
        // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.
        // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image
        // should be resized to the sufficient dimension.
        return true // do not create a new size
        ;
    }
    return false // needs resize
    ;
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath, uploadEdits }) {
    const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload;
    // Focal point adjustments
    const incomingFocalPoint = uploadEdits?.focalPoint ? {
        x: (0, _isNumber.isNumber)(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
        y: (0, _isNumber.isNumber)(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50
    } : undefined;
    const defaultResult = {
        ...focalPointEnabled && incomingFocalPoint && {
            focalPoint: incomingFocalPoint
        },
        sizeData: {},
        sizesToSave: []
    };
    // Nothing to resize here so return as early as possible
    if (!imageSizes) return defaultResult;
    // Determine if the file is animated
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const sharpOptions = {};
    if (fileIsAnimatedType) sharpOptions.animated = true;
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        // This checks if a resize should happen. If not, the resized image will be
        // skipped COMPLETELY and thus will not be included in the resulting images.
        // All further format/trim options will thus be skipped as well.
        if (preventResize(imageResizeConfig, dimensions)) {
            return createResult({
                name: imageResizeConfig.name
            });
        }
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        const metadata = await sharpBase.metadata();
        if (incomingFocalPoint && applyPayloadAdjustments(imageResizeConfig, dimensions)) {
            let { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const originalAspectRatio = dimensions.width / dimensions.height;
            // Calculate resizeWidth based on original aspect ratio if it's undefined
            if (resizeHeight && !resizeWidth) {
                resizeWidth = Math.round(resizeHeight * originalAspectRatio);
            }
            // Calculate resizeHeight based on original aspect ratio if it's undefined
            if (resizeWidth && !resizeHeight) {
                resizeHeight = Math.round(resizeWidth / originalAspectRatio);
            }
            // Scale the image up or down to fit the resize dimensions
            const scaledImage = imageToResize.resize({
                height: resizeHeight,
                width: resizeWidth
            });
            const { info: scaledImageInfo } = await scaledImage.toBuffer({
                resolveWithObject: true
            });
            const safeResizeWidth = resizeWidth ?? scaledImageInfo.width;
            const maxOffsetX = scaledImageInfo.width - safeResizeWidth;
            const leftFocalEdge = Math.round(scaledImageInfo.width * (incomingFocalPoint.x / 100) - safeResizeWidth / 2);
            const safeOffsetX = Math.min(Math.max(0, leftFocalEdge), maxOffsetX);
            const isAnimated = fileIsAnimatedType && metadata.pages;
            let safeResizeHeight = resizeHeight ?? scaledImageInfo.height;
            if (isAnimated && resizeHeight === undefined) {
                safeResizeHeight = scaledImageInfo.height / metadata.pages;
            }
            const maxOffsetY = isAnimated ? safeResizeHeight - (resizeHeight ?? safeResizeHeight) : scaledImageInfo.height - safeResizeHeight;
            const topFocalEdge = Math.round(scaledImageInfo.height * (incomingFocalPoint.y / 100) - safeResizeHeight / 2);
            const safeOffsetY = Math.min(Math.max(0, topFocalEdge), maxOffsetY);
            // extract the focal area from the scaled image
            resized = (fileIsAnimatedType ? imageToResize : scaledImage).extract({
                height: safeResizeHeight,
                left: safeOffsetX,
                top: safeOffsetY,
                width: safeResizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName(sanitizedImage.name, bufferInfo, mimeInfo?.ext || sanitizedImage.ext);
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult({
            name: imageResizeConfig.name,
            filename: imageNameWithDimensions,
            filesize: size,
            height: fileIsAnimatedType && metadata.pages ? height / metadata.pages : height,
            mimeType: mimeInfo?.mime || mimeType,
            sizesToSave: [
                {
                    buffer: bufferData,
                    path: imagePath
                }
            ],
            width
        });
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, defaultResult);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgT3V0cHV0SW5mbywgU2hhcnAsIFNoYXJwT3B0aW9ucyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFNhbml0aXplZENvbGxlY3Rpb25Db25maWcgfSBmcm9tICcuLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmlsZVNpemUsXG4gIEZpbGVTaXplcyxcbiAgRmlsZVRvU2F2ZSxcbiAgSW1hZ2VTaXplLFxuICBQcm9iZWRJbWFnZVNpemUsXG4gIFVwbG9hZEVkaXRzLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4uL3V0aWxpdGllcy9pc051bWJlcidcbmltcG9ydCBmaWxlRXhpc3RzIGZyb20gJy4vZmlsZUV4aXN0cydcblxudHlwZSBSZXNpemVBcmdzID0ge1xuICBjb25maWc6IFNhbml0aXplZENvbGxlY3Rpb25Db25maWdcbiAgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplXG4gIGZpbGU6IFVwbG9hZGVkRmlsZVxuICBtaW1lVHlwZTogc3RyaW5nXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgc2F2ZWRGaWxlbmFtZTogc3RyaW5nXG4gIHN0YXRpY1BhdGg6IHN0cmluZ1xuICB1cGxvYWRFZGl0cz86IFVwbG9hZEVkaXRzXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgZm9jYWxQb2ludD86IFVwbG9hZEVkaXRzWydmb2NhbFBvaW50J11cbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cbmNvbnN0IGNyZWF0ZUltYWdlTmFtZSA9IChcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmcsXG4gIHsgaGVpZ2h0LCB3aWR0aCB9OiBPdXRwdXRJbmZvLFxuICBleHRlbnNpb246IHN0cmluZyxcbikgPT4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxuXG50eXBlIENyZWF0ZVJlc3VsdEFyZ3MgPSB7XG4gIGZpbGVuYW1lPzogRmlsZVNpemVbJ2ZpbGVuYW1lJ11cbiAgZmlsZXNpemU/OiBGaWxlU2l6ZVsnZmlsZXNpemUnXVxuICBoZWlnaHQ/OiBGaWxlU2l6ZVsnaGVpZ2h0J11cbiAgbWltZVR5cGU/OiBGaWxlU2l6ZVsnbWltZVR5cGUnXVxuICBuYW1lOiBzdHJpbmdcbiAgc2l6ZXNUb1NhdmU/OiBGaWxlVG9TYXZlW11cbiAgd2lkdGg/OiBGaWxlU2l6ZVsnd2lkdGgnXVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKHtcbiAgbmFtZSxcbiAgZmlsZW5hbWUgPSBudWxsLFxuICBmaWxlc2l6ZSA9IG51bGwsXG4gIGhlaWdodCA9IG51bGwsXG4gIG1pbWVUeXBlID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmUgPSBbXSxcbiAgd2lkdGggPSBudWxsLFxufTogQ3JlYXRlUmVzdWx0QXJncyk6IEltYWdlU2l6ZXNSZXN1bHQgPT4ge1xuICByZXR1cm4ge1xuICAgIHNpemVEYXRhOiB7XG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZpbGVzaXplLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzaXplc1RvU2F2ZSxcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnNcbiAqIGFuZCB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS4gSWYgdGhlIHJlc2l6ZSBvcHRpb25zIHdpdGhvdXRFbmxhcmdlbWVudCBvciB3aXRob3V0UmVkdWN0aW9uIGFyZSBwcm92aWRlZCxcbiAqIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgcmVnYXJkbGVzcyBvZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMsIGdpdmVuIHRoYXQgdGhlXG4gKiB3aWR0aCBvciBoZWlnaHQgdG8gYmUgcmVzaXplZCBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgcmVzaXppbmcgaXMgbm90IG5lZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IHByZXZlbnRSZXNpemUgPSAoXG4gIHsgaGVpZ2h0OiBkZXNpcmVkSGVpZ2h0LCB3aWR0aDogZGVzaXJlZFdpZHRoLCB3aXRob3V0RW5sYXJnZW1lbnQsIHdpdGhvdXRSZWR1Y3Rpb24gfTogSW1hZ2VTaXplLFxuICBvcmlnaW5hbDogUHJvYmVkSW1hZ2VTaXplLFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIGRlZmF1bHQgaXMgdG8gYWxsb3cgcmVkdWN0aW9uXG4gIGlmICh3aXRob3V0UmVkdWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICAvLyBkZWZhdWx0IGlzIHRvIHByZXZlbnQgZW5sYXJnZW1lbnRcbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5lZWRzIHJlc2l6ZVxuICB9XG5cbiAgY29uc3QgaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCA9ICFkZXNpcmVkSGVpZ2h0IHx8ICFkZXNpcmVkV2lkdGhcbiAgaWYgKGlzV2lkdGhPckhlaWdodE5vdERlZmluZWQpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZGVmaW5lZCwgaXQgbWVhbnMgdGhlcmUgaXMgYSBmb3JtYXQgY29udmVyc2lvblxuICAgIC8vIGFuZCB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgXCJyZXNpemVkXCIgKHRyYW5zZm9ybWVkKS5cbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICBjb25zdCBoYXNJbnN1ZmZpY2llbnRXaWR0aCA9IGRlc2lyZWRXaWR0aCA+IG9yaWdpbmFsLndpZHRoXG4gIGNvbnN0IGhhc0luc3VmZmljaWVudEhlaWdodCA9IGRlc2lyZWRIZWlnaHQgPiBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKGhhc0luc3VmZmljaWVudFdpZHRoICYmIGhhc0luc3VmZmljaWVudEhlaWdodCkge1xuICAgIC8vIGRvZXNuJ3QgbmVlZCByZXNpemUgLSBwcmV2ZW50IGVubGFyZ2VtZW50LiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGluc3VmZmljaWVudC5cbiAgICAvLyBpZiBvbmx5IG9uZSBkaW1lbnNpb24gaXMgaW5zdWZmaWNpZW50IGFuZCB0aGUgb3RoZXIgaXMgc3VmZmljaWVudCwgcmVzaXppbmcgbmVlZHMgdG8gaGFwcGVuLCBhcyB0aGUgaW1hZ2VcbiAgICAvLyBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgc3VmZmljaWVudCBkaW1lbnNpb24uXG4gICAgcmV0dXJuIHRydWUgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBzaXplXG4gIH1cblxuICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGltYWdlIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gc2hhcnAgd2l0aG91dCBwYXlsb2FkIGFkanVzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYW5kIHJlc2l6ZSBvcHRpb25zXG4gKiBAcGFyYW0gb3JpZ2luYWwgLSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIHBhc3NlZCBkaXJlY3RseSB0byBzaGFycFxuICovXG5jb25zdCBhcHBseVBheWxvYWRBZGp1c3RtZW50cyA9IChcbiAgeyBmaXQsIGhlaWdodCwgd2lkdGgsIHdpdGhvdXRFbmxhcmdlbWVudCwgd2l0aG91dFJlZHVjdGlvbiB9OiBJbWFnZVNpemUsXG4gIG9yaWdpbmFsOiBQcm9iZWRJbWFnZVNpemUsXG4pID0+IHtcbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nIHx8IGZpdCA9PT0gJ2luc2lkZScpIHJldHVybiBmYWxzZVxuICBpZiAoIWlzTnVtYmVyKGhlaWdodCkgJiYgIWlzTnVtYmVyKHdpZHRoKSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodFxuICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gb3JpZ2luYWwud2lkdGggLyBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKG9yaWdpbmFsQXNwZWN0UmF0aW8gPT09IHRhcmdldEFzcGVjdFJhdGlvKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBza2lwRW5sYXJnZW1lbnQgPSB3aXRob3V0RW5sYXJnZW1lbnQgJiYgKG9yaWdpbmFsLmhlaWdodCA8IGhlaWdodCB8fCBvcmlnaW5hbC53aWR0aCA8IHdpZHRoKVxuICBjb25zdCBza2lwUmVkdWN0aW9uID0gd2l0aG91dFJlZHVjdGlvbiAmJiAob3JpZ2luYWwuaGVpZ2h0ID4gaGVpZ2h0IHx8IG9yaWdpbmFsLndpZHRoID4gd2lkdGgpXG4gIGlmIChza2lwRW5sYXJnZW1lbnQgfHwgc2tpcFJlZHVjdGlvbikgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgcmVzaXplIGNvbmZpZy4gSWYgdGhlIHJlc2l6ZSBjb25maWcgaGFzIHRoZSBgd2l0aG91dFJlZHVjdGlvbmBcbiAqIHByb3BlcnR5IHNldCB0byB0cnVlLCB0aGUgYGZpdGAgYW5kIGBwb3NpdGlvbmAgcHJvcGVydGllcyB3aWxsIGJlIHNldCB0byBgY29udGFpbmBcbiAqIGFuZCBgdG9wIGxlZnRgIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIGEgc2FuaXRpemVkIHJlc2l6ZSBjb25maWdcbiAqL1xuY29uc3Qgc2FuaXRpemVSZXNpemVDb25maWcgPSAocmVzaXplQ29uZmlnOiBJbWFnZVNpemUpOiBJbWFnZVNpemUgPT4ge1xuICBpZiAocmVzaXplQ29uZmlnLndpdGhvdXRSZWR1Y3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzaXplQ29uZmlnLFxuICAgICAgLy8gV2h5IGZpdCBgY29udGFpbmAgc2hvdWxkIGFsc28gYmUgc2V0IHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvaXNzdWVzLzM1OTVcbiAgICAgIGZpdDogcmVzaXplQ29uZmlnPy5maXQgfHwgJ2NvbnRhaW4nLFxuICAgICAgcG9zaXRpb246IHJlc2l6ZUNvbmZpZz8ucG9zaXRpb24gfHwgJ2xlZnQgdG9wJyxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2l6ZUNvbmZpZ1xufVxuXG4vKipcbiAqIEZvciB0aGUgcHJvdmlkZWQgaW1hZ2Ugc2l6ZXMsIGhhbmRsZSB0aGUgcmVzaXppbmcgYW5kIHRoZSB0cmFuc2Zvcm1zXG4gKiAoZm9ybWF0LCB0cmltLCBldGMuKSBvZiBlYWNoIHJlcXVlc3RlZCBpbWFnZSBzaXplIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvYmplY3QuXG4gKiBUaGlzIG9ubHkgaGFuZGxlcyB0aGUgaW1hZ2Ugc2l6ZXMuIFRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICogYXJlIGhhbmRsZWQgaW4ge0BsaW5rIC4vZ2VuZXJhdGVGaWxlRGF0YS50c30uXG4gKlxuICogVGhlIGltYWdlIHdpbGwgYmUgcmVzaXplZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gKiByZXNpemUgY29uZmlnLiBJZiBubyBpbWFnZSBzaXplcyBhcmUgcmVxdWVzdGVkLCB0aGUgcmVzb2x2ZWQgZGF0YSB3aWxsIGJlIGVtcHR5LlxuICogRm9yIGV2ZXJ5IGltYWdlIHRoYXQgZG9lcyBub3QgbmVlZCB0byBiZSByZXNpemVkLCBhIHJlc3VsdCBvYmplY3Qgd2l0aCBgbnVsbGBcbiAqIHBhcmFtZXRlcnMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHJlc2l6ZSBvcGVyYXRpb24ocylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyh7XG4gIGNvbmZpZyxcbiAgZGltZW5zaW9ucyxcbiAgZmlsZSxcbiAgbWltZVR5cGUsXG4gIHJlcSxcbiAgc2F2ZWRGaWxlbmFtZSxcbiAgc3RhdGljUGF0aCxcbiAgdXBsb2FkRWRpdHMsXG59OiBSZXNpemVBcmdzKTogUHJvbWlzZTxJbWFnZVNpemVzUmVzdWx0PiB7XG4gIGNvbnN0IHsgZm9jYWxQb2ludDogZm9jYWxQb2ludEVuYWJsZWQgPSB0cnVlLCBpbWFnZVNpemVzIH0gPSBjb25maWcudXBsb2FkXG5cbiAgLy8gRm9jYWwgcG9pbnQgYWRqdXN0bWVudHNcbiAgY29uc3QgaW5jb21pbmdGb2NhbFBvaW50ID0gdXBsb2FkRWRpdHM/LmZvY2FsUG9pbnRcbiAgICA/IHtcbiAgICAgICAgeDogaXNOdW1iZXIodXBsb2FkRWRpdHMuZm9jYWxQb2ludC54KSA/IE1hdGgucm91bmQodXBsb2FkRWRpdHMuZm9jYWxQb2ludC54KSA6IDUwLFxuICAgICAgICB5OiBpc051bWJlcih1cGxvYWRFZGl0cy5mb2NhbFBvaW50LnkpID8gTWF0aC5yb3VuZCh1cGxvYWRFZGl0cy5mb2NhbFBvaW50LnkpIDogNTAsXG4gICAgICB9XG4gICAgOiB1bmRlZmluZWRcblxuICBjb25zdCBkZWZhdWx0UmVzdWx0OiBJbWFnZVNpemVzUmVzdWx0ID0ge1xuICAgIC4uLihmb2NhbFBvaW50RW5hYmxlZCAmJiBpbmNvbWluZ0ZvY2FsUG9pbnQgJiYgeyBmb2NhbFBvaW50OiBpbmNvbWluZ0ZvY2FsUG9pbnQgfSksXG4gICAgc2l6ZURhdGE6IHt9LFxuICAgIHNpemVzVG9TYXZlOiBbXSxcbiAgfVxuXG4gIC8vIE5vdGhpbmcgdG8gcmVzaXplIGhlcmUgc28gcmV0dXJuIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG4gIGlmICghaW1hZ2VTaXplcykgcmV0dXJuIGRlZmF1bHRSZXN1bHRcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZpbGUgaXMgYW5pbWF0ZWRcbiAgY29uc3QgZmlsZUlzQW5pbWF0ZWRUeXBlID0gWydpbWFnZS9hdmlmJywgJ2ltYWdlL2dpZicsICdpbWFnZS93ZWJwJ10uaW5jbHVkZXMoZmlsZS5taW1ldHlwZSlcbiAgY29uc3Qgc2hhcnBPcHRpb25zOiBTaGFycE9wdGlvbnMgPSB7fVxuXG4gIGlmIChmaWxlSXNBbmltYXRlZFR5cGUpIHNoYXJwT3B0aW9ucy5hbmltYXRlZCA9IHRydWVcblxuICBjb25zdCBzaGFycEJhc2U6IFNoYXJwIHwgdW5kZWZpbmVkID0gc2hhcnAoZmlsZS50ZW1wRmlsZVBhdGggfHwgZmlsZS5kYXRhLCBzaGFycE9wdGlvbnMpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuXG4gIGNvbnN0IHJlc3VsdHM6IEltYWdlU2l6ZXNSZXN1bHRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGltYWdlU2l6ZXMubWFwKGFzeW5jIChpbWFnZVJlc2l6ZUNvbmZpZyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4gPT4ge1xuICAgICAgaW1hZ2VSZXNpemVDb25maWcgPSBzYW5pdGl6ZVJlc2l6ZUNvbmZpZyhpbWFnZVJlc2l6ZUNvbmZpZylcblxuICAgICAgLy8gVGhpcyBjaGVja3MgaWYgYSByZXNpemUgc2hvdWxkIGhhcHBlbi4gSWYgbm90LCB0aGUgcmVzaXplZCBpbWFnZSB3aWxsIGJlXG4gICAgICAvLyBza2lwcGVkIENPTVBMRVRFTFkgYW5kIHRodXMgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBpbWFnZXMuXG4gICAgICAvLyBBbGwgZnVydGhlciBmb3JtYXQvdHJpbSBvcHRpb25zIHdpbGwgdGh1cyBiZSBza2lwcGVkIGFzIHdlbGwuXG4gICAgICBpZiAocHJldmVudFJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZywgZGltZW5zaW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdCh7IG5hbWU6IGltYWdlUmVzaXplQ29uZmlnLm5hbWUgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemVcblxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBzaGFycEJhc2UubWV0YWRhdGEoKVxuXG4gICAgICBpZiAoaW5jb21pbmdGb2NhbFBvaW50ICYmIGFwcGx5UGF5bG9hZEFkanVzdG1lbnRzKGltYWdlUmVzaXplQ29uZmlnLCBkaW1lbnNpb25zKSkge1xuICAgICAgICBsZXQgeyBoZWlnaHQ6IHJlc2l6ZUhlaWdodCwgd2lkdGg6IHJlc2l6ZVdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHRcblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplV2lkdGggYmFzZWQgb24gb3JpZ2luYWwgYXNwZWN0IHJhdGlvIGlmIGl0J3MgdW5kZWZpbmVkXG4gICAgICAgIGlmIChyZXNpemVIZWlnaHQgJiYgIXJlc2l6ZVdpZHRoKSB7XG4gICAgICAgICAgcmVzaXplV2lkdGggPSBNYXRoLnJvdW5kKHJlc2l6ZUhlaWdodCAqIG9yaWdpbmFsQXNwZWN0UmF0aW8pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplSGVpZ2h0IGJhc2VkIG9uIG9yaWdpbmFsIGFzcGVjdCByYXRpbyBpZiBpdCdzIHVuZGVmaW5lZFxuICAgICAgICBpZiAocmVzaXplV2lkdGggJiYgIXJlc2l6ZUhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZUhlaWdodCA9IE1hdGgucm91bmQocmVzaXplV2lkdGggLyBvcmlnaW5hbEFzcGVjdFJhdGlvKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIGltYWdlIHVwIG9yIGRvd24gdG8gZml0IHRoZSByZXNpemUgZGltZW5zaW9uc1xuICAgICAgICBjb25zdCBzY2FsZWRJbWFnZSA9IGltYWdlVG9SZXNpemUucmVzaXplKHtcbiAgICAgICAgICBoZWlnaHQ6IHJlc2l6ZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogcmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgeyBpbmZvOiBzY2FsZWRJbWFnZUluZm8gfSA9IGF3YWl0IHNjYWxlZEltYWdlLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSlcblxuICAgICAgICBjb25zdCBzYWZlUmVzaXplV2lkdGggPSByZXNpemVXaWR0aCA/PyBzY2FsZWRJbWFnZUluZm8ud2lkdGhcbiAgICAgICAgY29uc3QgbWF4T2Zmc2V0WCA9IHNjYWxlZEltYWdlSW5mby53aWR0aCAtIHNhZmVSZXNpemVXaWR0aFxuICAgICAgICBjb25zdCBsZWZ0Rm9jYWxFZGdlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBzY2FsZWRJbWFnZUluZm8ud2lkdGggKiAoaW5jb21pbmdGb2NhbFBvaW50LnggLyAxMDApIC0gc2FmZVJlc2l6ZVdpZHRoIC8gMixcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBzYWZlT2Zmc2V0WCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGxlZnRGb2NhbEVkZ2UpLCBtYXhPZmZzZXRYKVxuXG4gICAgICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSBmaWxlSXNBbmltYXRlZFR5cGUgJiYgbWV0YWRhdGEucGFnZXNcblxuICAgICAgICBsZXQgc2FmZVJlc2l6ZUhlaWdodCA9IHJlc2l6ZUhlaWdodCA/PyBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0XG5cbiAgICAgICAgaWYgKGlzQW5pbWF0ZWQgJiYgcmVzaXplSGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzYWZlUmVzaXplSGVpZ2h0ID0gc2NhbGVkSW1hZ2VJbmZvLmhlaWdodCAvIG1ldGFkYXRhLnBhZ2VzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhPZmZzZXRZID0gaXNBbmltYXRlZFxuICAgICAgICAgID8gc2FmZVJlc2l6ZUhlaWdodCAtIChyZXNpemVIZWlnaHQgPz8gc2FmZVJlc2l6ZUhlaWdodClcbiAgICAgICAgICA6IHNjYWxlZEltYWdlSW5mby5oZWlnaHQgLSBzYWZlUmVzaXplSGVpZ2h0XG5cbiAgICAgICAgY29uc3QgdG9wRm9jYWxFZGdlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0ICogKGluY29taW5nRm9jYWxQb2ludC55IC8gMTAwKSAtIHNhZmVSZXNpemVIZWlnaHQgLyAyLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHNhZmVPZmZzZXRZID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdG9wRm9jYWxFZGdlKSwgbWF4T2Zmc2V0WSlcblxuICAgICAgICAvLyBleHRyYWN0IHRoZSBmb2NhbCBhcmVhIGZyb20gdGhlIHNjYWxlZCBpbWFnZVxuICAgICAgICByZXNpemVkID0gKGZpbGVJc0FuaW1hdGVkVHlwZSA/IGltYWdlVG9SZXNpemUgOiBzY2FsZWRJbWFnZSkuZXh0cmFjdCh7XG4gICAgICAgICAgaGVpZ2h0OiBzYWZlUmVzaXplSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IHNhZmVPZmZzZXRYLFxuICAgICAgICAgIHRvcDogc2FmZU9mZnNldFksXG4gICAgICAgICAgd2lkdGg6IHNhZmVSZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2l6ZWQgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZylcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudG9Gb3JtYXQoXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5vcHRpb25zLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucykge1xuICAgICAgICByZXNpemVkID0gcmVzaXplZC50cmltKGltYWdlUmVzaXplQ29uZmlnLnRyaW1PcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGE6IGJ1ZmZlckRhdGEsIGluZm86IGJ1ZmZlckluZm8gfSA9IGF3YWl0IHJlc2l6ZWQudG9CdWZmZXIoe1xuICAgICAgICByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNhbml0aXplZEltYWdlID0gZ2V0U2FuaXRpemVkSW1hZ2VEYXRhKHNhdmVkRmlsZW5hbWUpXG5cbiAgICAgIGlmIChyZXEucGF5bG9hZFVwbG9hZFNpemVzKSB7XG4gICAgICAgIHJlcS5wYXlsb2FkVXBsb2FkU2l6ZXNbaW1hZ2VSZXNpemVDb25maWcubmFtZV0gPSBidWZmZXJEYXRhXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pbWVJbmZvID0gYXdhaXQgZnJvbUJ1ZmZlcihidWZmZXJEYXRhKVxuXG4gICAgICBjb25zdCBpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyA9IGNyZWF0ZUltYWdlTmFtZShcbiAgICAgICAgc2FuaXRpemVkSW1hZ2UubmFtZSxcbiAgICAgICAgYnVmZmVySW5mbyxcbiAgICAgICAgbWltZUluZm8/LmV4dCB8fCBzYW5pdGl6ZWRJbWFnZS5leHQsXG4gICAgICApXG5cbiAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGAke3N0YXRpY1BhdGh9LyR7aW1hZ2VOYW1lV2l0aERpbWVuc2lvbnN9YFxuXG4gICAgICBpZiAoYXdhaXQgZmlsZUV4aXN0cyhpbWFnZVBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhpbWFnZVBhdGgpXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElnbm9yZSB1bmxpbmsgZXJyb3JzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBoZWlnaHQsIHNpemUsIHdpZHRoIH0gPSBidWZmZXJJbmZvXG4gICAgICByZXR1cm4gY3JlYXRlUmVzdWx0KHtcbiAgICAgICAgbmFtZTogaW1hZ2VSZXNpemVDb25maWcubmFtZSxcbiAgICAgICAgZmlsZW5hbWU6IGltYWdlTmFtZVdpdGhEaW1lbnNpb25zLFxuICAgICAgICBmaWxlc2l6ZTogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBmaWxlSXNBbmltYXRlZFR5cGUgJiYgbWV0YWRhdGEucGFnZXMgPyBoZWlnaHQgLyBtZXRhZGF0YS5wYWdlcyA6IGhlaWdodCxcbiAgICAgICAgbWltZVR5cGU6IG1pbWVJbmZvPy5taW1lIHx8IG1pbWVUeXBlLFxuICAgICAgICBzaXplc1RvU2F2ZTogW3sgYnVmZmVyOiBidWZmZXJEYXRhLCBwYXRoOiBpbWFnZVBhdGggfV0sXG4gICAgICAgIHdpZHRoLFxuICAgICAgfSlcbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjLCByZXN1bHQpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKGFjYy5zaXplRGF0YSwgcmVzdWx0LnNpemVEYXRhKVxuICAgIGFjYy5zaXplc1RvU2F2ZS5wdXNoKC4uLnJlc3VsdC5zaXplc1RvU2F2ZSlcbiAgICByZXR1cm4gYWNjXG4gIH0sIGRlZmF1bHRSZXN1bHQpXG59XG4iXSwibmFtZXMiOlsicmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyIsImdldFNhbml0aXplZEltYWdlRGF0YSIsInNvdXJjZUltYWdlIiwiZXh0ZW5zaW9uIiwic3BsaXQiLCJwb3AiLCJuYW1lIiwic2FuaXRpemUiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImV4dCIsImNyZWF0ZUltYWdlTmFtZSIsIm91dHB1dEltYWdlTmFtZSIsImhlaWdodCIsIndpZHRoIiwiY3JlYXRlUmVzdWx0IiwiZmlsZW5hbWUiLCJmaWxlc2l6ZSIsIm1pbWVUeXBlIiwic2l6ZXNUb1NhdmUiLCJzaXplRGF0YSIsInByZXZlbnRSZXNpemUiLCJkZXNpcmVkSGVpZ2h0IiwiZGVzaXJlZFdpZHRoIiwid2l0aG91dEVubGFyZ2VtZW50Iiwid2l0aG91dFJlZHVjdGlvbiIsIm9yaWdpbmFsIiwidW5kZWZpbmVkIiwiaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCIsImhhc0luc3VmZmljaWVudFdpZHRoIiwiaGFzSW5zdWZmaWNpZW50SGVpZ2h0IiwiYXBwbHlQYXlsb2FkQWRqdXN0bWVudHMiLCJmaXQiLCJpc051bWJlciIsInRhcmdldEFzcGVjdFJhdGlvIiwib3JpZ2luYWxBc3BlY3RSYXRpbyIsInNraXBFbmxhcmdlbWVudCIsInNraXBSZWR1Y3Rpb24iLCJzYW5pdGl6ZVJlc2l6ZUNvbmZpZyIsInJlc2l6ZUNvbmZpZyIsInBvc2l0aW9uIiwiY29uZmlnIiwiZGltZW5zaW9ucyIsImZpbGUiLCJyZXEiLCJzYXZlZEZpbGVuYW1lIiwic3RhdGljUGF0aCIsInVwbG9hZEVkaXRzIiwiZm9jYWxQb2ludCIsImZvY2FsUG9pbnRFbmFibGVkIiwiaW1hZ2VTaXplcyIsInVwbG9hZCIsImluY29taW5nRm9jYWxQb2ludCIsIngiLCJNYXRoIiwicm91bmQiLCJ5IiwiZGVmYXVsdFJlc3VsdCIsImZpbGVJc0FuaW1hdGVkVHlwZSIsImluY2x1ZGVzIiwibWltZXR5cGUiLCJzaGFycE9wdGlvbnMiLCJhbmltYXRlZCIsInNoYXJwQmFzZSIsInNoYXJwIiwidGVtcEZpbGVQYXRoIiwiZGF0YSIsInJvdGF0ZSIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaW1hZ2VSZXNpemVDb25maWciLCJpbWFnZVRvUmVzaXplIiwiY2xvbmUiLCJyZXNpemVkIiwibWV0YWRhdGEiLCJyZXNpemVIZWlnaHQiLCJyZXNpemVXaWR0aCIsInNjYWxlZEltYWdlIiwicmVzaXplIiwiaW5mbyIsInNjYWxlZEltYWdlSW5mbyIsInRvQnVmZmVyIiwicmVzb2x2ZVdpdGhPYmplY3QiLCJzYWZlUmVzaXplV2lkdGgiLCJtYXhPZmZzZXRYIiwibGVmdEZvY2FsRWRnZSIsInNhZmVPZmZzZXRYIiwibWluIiwibWF4IiwiaXNBbmltYXRlZCIsInBhZ2VzIiwic2FmZVJlc2l6ZUhlaWdodCIsIm1heE9mZnNldFkiLCJ0b3BGb2NhbEVkZ2UiLCJzYWZlT2Zmc2V0WSIsImV4dHJhY3QiLCJsZWZ0IiwidG9wIiwiZm9ybWF0T3B0aW9ucyIsInRvRm9ybWF0IiwiZm9ybWF0Iiwib3B0aW9ucyIsInRyaW1PcHRpb25zIiwidHJpbSIsImJ1ZmZlckRhdGEiLCJidWZmZXJJbmZvIiwic2FuaXRpemVkSW1hZ2UiLCJwYXlsb2FkVXBsb2FkU2l6ZXMiLCJtaW1lSW5mbyIsImZyb21CdWZmZXIiLCJpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyIsImltYWdlUGF0aCIsImZpbGVFeGlzdHMiLCJmcyIsInVubGlua1N5bmMiLCJzaXplIiwibWltZSIsImJ1ZmZlciIsInBhdGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHQiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJtYXBwaW5ncyI6Ijs7OzsrQkFtTkE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEOzs7ZUFBOEJBOzs7MEJBOU5IOzJEQUNaO3lFQUNNOzhEQUNIOzBCQWFPO21FQUNGOzs7Ozs7QUF5QnZCOzs7OztDQUtDLEdBQ0QsTUFBTUMsd0JBQXdCLENBQUNDO0lBQzdCLE1BQU1DLFlBQVlELFlBQVlFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzVDLE1BQU1DLE9BQU9DLElBQUFBLHlCQUFRLEVBQUNMLFlBQVlNLFNBQVMsQ0FBQyxHQUFHTixZQUFZTyxXQUFXLENBQUMsU0FBU1A7SUFDaEYsT0FBTztRQUFFSTtRQUFNSSxLQUFLUDtJQUFVO0FBQ2hDO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsTUFBTVEsa0JBQWtCLENBQ3RCQyxpQkFDQSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBYyxFQUM3QlgsWUFDRyxDQUFDLEVBQUVTLGdCQUFnQixDQUFDLEVBQUVFLE1BQU0sQ0FBQyxFQUFFRCxPQUFPLENBQUMsRUFBRVYsVUFBVSxDQUFDO0FBWXpEOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxNQUFNWSxlQUFlLENBQUMsRUFDcEJULElBQUksRUFDSlUsV0FBVyxJQUFJ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