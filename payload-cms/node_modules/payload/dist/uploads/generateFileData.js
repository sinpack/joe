"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateFileData", {
    enumerable: true,
    get: function() {
        return generateFileData;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _mkdirp = /*#__PURE__*/ _interop_require_default(require("mkdirp"));
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _errors = require("../errors");
const _FileRetrievalError = /*#__PURE__*/ _interop_require_default(require("../errors/FileRetrievalError"));
const _canResizeImage = /*#__PURE__*/ _interop_require_default(require("./canResizeImage"));
const _cropImage = /*#__PURE__*/ _interop_require_default(require("./cropImage"));
const _getExternalFile = require("./getExternalFile");
const _getFileByPath = /*#__PURE__*/ _interop_require_default(require("./getFileByPath"));
const _getImageSize = /*#__PURE__*/ _interop_require_default(require("./getImageSize"));
const _getSafeFilename = /*#__PURE__*/ _interop_require_default(require("./getSafeFilename"));
const _imageResizer = /*#__PURE__*/ _interop_require_default(require("./imageResizer"));
const _isImage = /*#__PURE__*/ _interop_require_default(require("./isImage"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const generateFileData = async ({ collection: { config: collectionConfig }, config, data, operation, originalDoc, overwriteExistingFiles, req, throwOnMissingFile })=>{
    if (!collectionConfig.upload) {
        return {
            data,
            files: []
        };
    }
    let file = req.files?.file || undefined;
    const uploadEdits = parseUploadEditsFromReqOrIncomingData({
        data,
        operation,
        originalDoc,
        req
    });
    const { disableLocalStorage, focalPoint: focalPointEnabled, formatOptions, imageSizes, resizeOptions, staticDir, trimOptions } = collectionConfig.upload;
    let staticPath = staticDir;
    if (staticDir.indexOf('/') !== 0) {
        staticPath = _path.default.resolve(config.paths.configDir, staticDir);
    }
    if (!file && uploadEdits && data) {
        const { filename, url } = data;
        try {
            if (url && url.startsWith('/') && !disableLocalStorage) {
                const filePath = `${staticPath}/${filename}`;
                const response = await (0, _getFileByPath.default)(filePath);
                file = response;
                overwriteExistingFiles = true;
            } else if (filename && url) {
                file = await (0, _getExternalFile.getExternalFile)({
                    data: data,
                    req,
                    uploadConfig: collectionConfig.upload
                });
                overwriteExistingFiles = true;
            }
        } catch (err) {
            if (err instanceof Error) {
                throw new _FileRetrievalError.default(req.t, err.message);
            }
        }
    }
    if (!file) {
        if (throwOnMissingFile) throw new _errors.MissingFile(req.t);
        return {
            data,
            files: []
        };
    }
    if (!disableLocalStorage) {
        _mkdirp.default.sync(staticPath);
    }
    let newData = data;
    const filesToSave = [];
    const fileData = {};
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const cropData = typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined;
    try {
        const fileSupportsResize = (0, _canResizeImage.default)(file.mimetype);
        let fsSafeName;
        let sharpFile;
        let dimensions;
        let fileBuffer;
        let ext;
        let mime;
        const fileHasAdjustments = fileSupportsResize && Boolean(resizeOptions || formatOptions || imageSizes || trimOptions || file.tempFilePath);
        const sharpOptions = {};
        if (fileIsAnimatedType) sharpOptions.animated = true;
        if (_sharp.default && (fileIsAnimatedType || fileHasAdjustments)) {
            if (file.tempFilePath) {
                sharpFile = (0, _sharp.default)(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            } else {
                sharpFile = (0, _sharp.default)(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            }
            if (fileHasAdjustments) {
                if (resizeOptions) {
                    sharpFile = sharpFile.resize(resizeOptions);
                }
                if (formatOptions) {
                    sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options);
                }
                if (trimOptions) {
                    sharpFile = sharpFile.trim(trimOptions);
                }
            }
        }
        if (fileSupportsResize || (0, _isImage.default)(file.mimetype)) {
            dimensions = await (0, _getImageSize.default)(file);
            fileData.width = dimensions.width;
            fileData.height = dimensions.height;
        }
        if (sharpFile) {
            const metadata = await sharpFile.metadata();
            fileBuffer = await sharpFile.toBuffer({
                resolveWithObject: true
            });
            ({ ext, mime } = await (0, _filetype.fromBuffer)(fileBuffer.data) // This is getting an incorrect gif height back.
            );
            fileData.width = fileBuffer.info.width;
            fileData.height = fileBuffer.info.height;
            fileData.filesize = fileBuffer.info.size;
            // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages
            if (metadata.pages) {
                fileData.height = fileBuffer.info.height / metadata.pages;
                fileData.filesize = fileBuffer.data.length;
            }
        } else {
            mime = file.mimetype;
            fileData.filesize = file.size;
            if (file.name.includes('.')) {
                ext = file.name.split('.').pop().split('?')[0];
            } else {
                ext = '';
            }
        }
        // Adjust SVG mime type. fromBuffer modifies it.
        if (mime === 'application/xml' && ext === 'svg') mime = 'image/svg+xml';
        fileData.mimeType = mime;
        const baseFilename = (0, _sanitizefilename.default)(file.name.substring(0, file.name.lastIndexOf('.')) || file.name);
        fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`;
        if (!overwriteExistingFiles) {
            fsSafeName = await (0, _getSafeFilename.default)({
                collectionSlug: collectionConfig.slug,
                desiredFilename: fsSafeName,
                req,
                staticPath
            });
        }
        fileData.filename = fsSafeName;
        let fileForResize = file;
        if (cropData) {
            const { data: croppedImage, info } = await (0, _cropImage.default)({
                cropData,
                dimensions,
                file
            });
            filesToSave.push({
                buffer: croppedImage,
                path: `${staticPath}/${fsSafeName}`
            });
            fileForResize = {
                ...file,
                data: croppedImage,
                size: info.size
            };
            fileData.width = info.width;
            fileData.height = info.height;
            if (fileIsAnimatedType) {
                const metadata = await sharpFile.metadata();
                fileData.height = metadata.pages ? info.height / metadata.pages : info.height;
            }
            fileData.filesize = info.size;
            if (file.tempFilePath) {
                await _fs.default.promises.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path
                ;
            } else {
                req.files.file = fileForResize;
            }
        } else {
            filesToSave.push({
                buffer: fileBuffer?.data || file.data,
                path: `${staticPath}/${fsSafeName}`
            });
            // If using temp files and the image is being resized, write the file to the temp path
            if (fileBuffer?.data || file.data.length > 0) {
                if (file.tempFilePath) {
                    await _fs.default.promises.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path
                    ;
                } else {
                    // Assign the _possibly modified_ file to the request object
                    req.files.file = {
                        ...file,
                        data: fileBuffer?.data || file.data,
                        size: fileBuffer?.info.size
                    };
                }
            }
        }
        if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {
            req.payloadUploadSizes = {};
            const { focalPoint, sizeData, sizesToSave } = await (0, _imageResizer.default)({
                config: collectionConfig,
                dimensions: !cropData ? dimensions : {
                    ...dimensions,
                    height: fileData.height,
                    width: fileData.width
                },
                file: fileForResize,
                mimeType: fileData.mimeType,
                req,
                savedFilename: fsSafeName || file.name,
                staticPath,
                uploadEdits
            });
            fileData.sizes = sizeData;
            fileData.focalX = focalPoint?.x;
            fileData.focalY = focalPoint?.y;
            filesToSave.push(...sizesToSave);
        }
    } catch (err) {
        req.payload.logger.error({
            err,
            msg: 'Error uploading file'
        });
        throw new _errors.FileUploadError(req.t);
    }
    newData = {
        ...newData,
        ...fileData
    };
    return {
        data: newData,
        files: filesToSave
    };
};
/**
 * Parse upload edits from req or incoming data
 */ function parseUploadEditsFromReqOrIncomingData(args) {
    const { data, operation, originalDoc, req } = args;
    // Get intended focal point change from query string or incoming data
    const uploadEdits = req.query?.uploadEdits && typeof req.query.uploadEdits === 'object' ? req.query.uploadEdits : {};
    if (uploadEdits.focalPoint) return uploadEdits;
    const incomingData = data;
    const origDoc = originalDoc;
    // If no change in focal point, return undefined.
    // This prevents a refocal operation triggered from admin, because it always sends the focal point.
    if (origDoc && incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {
        return undefined;
    }
    if (incomingData.focalX && incomingData.focalY) {
        uploadEdits.focalPoint = {
            x: incomingData.focalX,
            y: incomingData.focalY
        };
        return uploadEdits;
    }
    // If no focal point is set, default to center
    if (operation === 'create') {
        uploadEdits.focalPoint = {
            x: 50,
            y: 50
        };
    }
    return uploadEdits;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2dlbmVyYXRlRmlsZURhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBVcGxvYWRlZEZpbGUgfSBmcm9tICdleHByZXNzLWZpbGV1cGxvYWQnXG5pbXBvcnQgdHlwZSB7IE91dHB1dEluZm8sIFNoYXJwLCBTaGFycE9wdGlvbnMgfSBmcm9tICdzaGFycCdcblxuaW1wb3J0IHsgZnJvbUJ1ZmZlciB9IGZyb20gJ2ZpbGUtdHlwZSdcbmltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBzYW5pdGl6ZSBmcm9tICdzYW5pdGl6ZS1maWxlbmFtZSdcbmltcG9ydCBzaGFycCBmcm9tICdzaGFycCdcblxuaW1wb3J0IHR5cGUgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb25maWcgfSBmcm9tICcuLi9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgRmlsZURhdGEsIEZpbGVUb1NhdmUsIFByb2JlZEltYWdlU2l6ZSwgVXBsb2FkRWRpdHMgfSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBGaWxlVXBsb2FkRXJyb3IsIE1pc3NpbmdGaWxlIH0gZnJvbSAnLi4vZXJyb3JzJ1xuaW1wb3J0IEZpbGVSZXRyaWV2YWxFcnJvciBmcm9tICcuLi9lcnJvcnMvRmlsZVJldHJpZXZhbEVycm9yJ1xuaW1wb3J0IGNhblJlc2l6ZUltYWdlIGZyb20gJy4vY2FuUmVzaXplSW1hZ2UnXG5pbXBvcnQgY3JvcEltYWdlIGZyb20gJy4vY3JvcEltYWdlJ1xuaW1wb3J0IHsgZ2V0RXh0ZXJuYWxGaWxlIH0gZnJvbSAnLi9nZXRFeHRlcm5hbEZpbGUnXG5pbXBvcnQgZ2V0RmlsZUJ5UGF0aCBmcm9tICcuL2dldEZpbGVCeVBhdGgnXG5pbXBvcnQgZ2V0SW1hZ2VTaXplIGZyb20gJy4vZ2V0SW1hZ2VTaXplJ1xuaW1wb3J0IGdldFNhZmVGaWxlTmFtZSBmcm9tICcuL2dldFNhZmVGaWxlbmFtZSdcbmltcG9ydCByZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIGZyb20gJy4vaW1hZ2VSZXNpemVyJ1xuaW1wb3J0IGlzSW1hZ2UgZnJvbSAnLi9pc0ltYWdlJ1xuXG50eXBlIEFyZ3M8VD4gPSB7XG4gIGNvbGxlY3Rpb246IENvbGxlY3Rpb25cbiAgY29uZmlnOiBTYW5pdGl6ZWRDb25maWdcbiAgZGF0YTogVFxuICBvcGVyYXRpb246ICdjcmVhdGUnIHwgJ3VwZGF0ZSdcbiAgb3JpZ2luYWxEb2M/OiBUXG4gIG92ZXJ3cml0ZUV4aXN0aW5nRmlsZXM/OiBib29sZWFuXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgdGhyb3dPbk1pc3NpbmdGaWxlPzogYm9vbGVhblxufVxuXG50eXBlIFJlc3VsdDxUPiA9IFByb21pc2U8e1xuICBkYXRhOiBUXG4gIGZpbGVzOiBGaWxlVG9TYXZlW11cbn0+XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUZpbGVEYXRhID0gYXN5bmMgPFQ+KHtcbiAgY29sbGVjdGlvbjogeyBjb25maWc6IGNvbGxlY3Rpb25Db25maWcgfSxcbiAgY29uZmlnLFxuICBkYXRhLFxuICBvcGVyYXRpb24sXG4gIG9yaWdpbmFsRG9jLFxuICBvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzLFxuICByZXEsXG4gIHRocm93T25NaXNzaW5nRmlsZSxcbn06IEFyZ3M8VD4pOiBSZXN1bHQ8VD4gPT4ge1xuICBpZiAoIWNvbGxlY3Rpb25Db25maWcudXBsb2FkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBmaWxlczogW10sXG4gICAgfVxuICB9XG5cbiAgbGV0IGZpbGUgPSByZXEuZmlsZXM/LmZpbGUgfHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgdXBsb2FkRWRpdHMgPSBwYXJzZVVwbG9hZEVkaXRzRnJvbVJlcU9ySW5jb21pbmdEYXRhKHtcbiAgICBkYXRhLFxuICAgIG9wZXJhdGlvbixcbiAgICBvcmlnaW5hbERvYyxcbiAgICByZXEsXG4gIH0pXG5cbiAgY29uc3Qge1xuICAgIGRpc2FibGVMb2NhbFN0b3JhZ2UsXG4gICAgZm9jYWxQb2ludDogZm9jYWxQb2ludEVuYWJsZWQsXG4gICAgZm9ybWF0T3B0aW9ucyxcbiAgICBpbWFnZVNpemVzLFxuICAgIHJlc2l6ZU9wdGlvbnMsXG4gICAgc3RhdGljRGlyLFxuICAgIHRyaW1PcHRpb25zLFxuICB9ID0gY29sbGVjdGlvbkNvbmZpZy51cGxvYWRcblxuICBsZXQgc3RhdGljUGF0aCA9IHN0YXRpY0RpclxuICBpZiAoc3RhdGljRGlyLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuICAgIHN0YXRpY1BhdGggPSBwYXRoLnJlc29sdmUoY29uZmlnLnBhdGhzLmNvbmZpZ0Rpciwgc3RhdGljRGlyKVxuICB9XG5cbiAgaWYgKCFmaWxlICYmIHVwbG9hZEVkaXRzICYmIGRhdGEpIHtcbiAgICBjb25zdCB7IGZpbGVuYW1lLCB1cmwgfSA9IGRhdGEgYXMgRmlsZURhdGFcblxuICAgIHRyeSB7XG4gICAgICBpZiAodXJsICYmIHVybC5zdGFydHNXaXRoKCcvJykgJiYgIWRpc2FibGVMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgJHtzdGF0aWNQYXRofS8ke2ZpbGVuYW1lfWBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRGaWxlQnlQYXRoKGZpbGVQYXRoKVxuICAgICAgICBmaWxlID0gcmVzcG9uc2UgYXMgVXBsb2FkZWRGaWxlXG4gICAgICAgIG92ZXJ3cml0ZUV4aXN0aW5nRmlsZXMgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lICYmIHVybCkge1xuICAgICAgICBmaWxlID0gKGF3YWl0IGdldEV4dGVybmFsRmlsZSh7XG4gICAgICAgICAgZGF0YTogZGF0YSBhcyBGaWxlRGF0YSxcbiAgICAgICAgICByZXEsXG4gICAgICAgICAgdXBsb2FkQ29uZmlnOiBjb2xsZWN0aW9uQ29uZmlnLnVwbG9hZCxcbiAgICAgICAgfSkpIGFzIFVwbG9hZGVkRmlsZVxuICAgICAgICBvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWxlUmV0cmlldmFsRXJyb3IocmVxLnQsIGVyci5tZXNzYWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZmlsZSkge1xuICAgIGlmICh0aHJvd09uTWlzc2luZ0ZpbGUpIHRocm93IG5ldyBNaXNzaW5nRmlsZShyZXEudClcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZmlsZXM6IFtdLFxuICAgIH1cbiAgfVxuXG4gIGlmICghZGlzYWJsZUxvY2FsU3RvcmFnZSkge1xuICAgIG1rZGlycC5zeW5jKHN0YXRpY1BhdGgpXG4gIH1cblxuICBsZXQgbmV3RGF0YSA9IGRhdGFcbiAgY29uc3QgZmlsZXNUb1NhdmU6IEZpbGVUb1NhdmVbXSA9IFtdXG4gIGNvbnN0IGZpbGVEYXRhOiBQYXJ0aWFsPEZpbGVEYXRhPiA9IHt9XG4gIGNvbnN0IGZpbGVJc0FuaW1hdGVkVHlwZSA9IFsnaW1hZ2UvYXZpZicsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCddLmluY2x1ZGVzKGZpbGUubWltZXR5cGUpXG4gIGNvbnN0IGNyb3BEYXRhID1cbiAgICB0eXBlb2YgdXBsb2FkRWRpdHMgPT09ICdvYmplY3QnICYmICdjcm9wJyBpbiB1cGxvYWRFZGl0cyA/IHVwbG9hZEVkaXRzLmNyb3AgOiB1bmRlZmluZWRcblxuICB0cnkge1xuICAgIGNvbnN0IGZpbGVTdXBwb3J0c1Jlc2l6ZSA9IGNhblJlc2l6ZUltYWdlKGZpbGUubWltZXR5cGUpXG4gICAgbGV0IGZzU2FmZU5hbWU6IHN0cmluZ1xuICAgIGxldCBzaGFycEZpbGU6IFNoYXJwIHwgdW5kZWZpbmVkXG4gICAgbGV0IGRpbWVuc2lvbnM6IFByb2JlZEltYWdlU2l6ZSB8IHVuZGVmaW5lZFxuICAgIGxldCBmaWxlQnVmZmVyOiB7IGRhdGE6IEJ1ZmZlcjsgaW5mbzogT3V0cHV0SW5mbyB9XG4gICAgbGV0IGV4dFxuICAgIGxldCBtaW1lOiBzdHJpbmdcbiAgICBjb25zdCBmaWxlSGFzQWRqdXN0bWVudHMgPVxuICAgICAgZmlsZVN1cHBvcnRzUmVzaXplICYmXG4gICAgICBCb29sZWFuKHJlc2l6ZU9wdGlvbnMgfHwgZm9ybWF0T3B0aW9ucyB8fCBpbWFnZVNpemVzIHx8IHRyaW1PcHRpb25zIHx8IGZpbGUudGVtcEZpbGVQYXRoKVxuXG4gICAgY29uc3Qgc2hhcnBPcHRpb25zOiBTaGFycE9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKGZpbGVJc0FuaW1hdGVkVHlwZSkgc2hhcnBPcHRpb25zLmFuaW1hdGVkID0gdHJ1ZVxuXG4gICAgaWYgKHNoYXJwICYmIChmaWxlSXNBbmltYXRlZFR5cGUgfHwgZmlsZUhhc0FkanVzdG1lbnRzKSkge1xuICAgICAgaWYgKGZpbGUudGVtcEZpbGVQYXRoKSB7XG4gICAgICAgIHNoYXJwRmlsZSA9IHNoYXJwKGZpbGUudGVtcEZpbGVQYXRoLCBzaGFycE9wdGlvbnMpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcnBGaWxlID0gc2hhcnAoZmlsZS5kYXRhLCBzaGFycE9wdGlvbnMpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsZUhhc0FkanVzdG1lbnRzKSB7XG4gICAgICAgIGlmIChyZXNpemVPcHRpb25zKSB7XG4gICAgICAgICAgc2hhcnBGaWxlID0gc2hhcnBGaWxlLnJlc2l6ZShyZXNpemVPcHRpb25zKVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXRPcHRpb25zKSB7XG4gICAgICAgICAgc2hhcnBGaWxlID0gc2hhcnBGaWxlLnRvRm9ybWF0KGZvcm1hdE9wdGlvbnMuZm9ybWF0LCBmb3JtYXRPcHRpb25zLm9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1PcHRpb25zKSB7XG4gICAgICAgICAgc2hhcnBGaWxlID0gc2hhcnBGaWxlLnRyaW0odHJpbU9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlsZVN1cHBvcnRzUmVzaXplIHx8IGlzSW1hZ2UoZmlsZS5taW1ldHlwZSkpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBhd2FpdCBnZXRJbWFnZVNpemUoZmlsZSlcbiAgICAgIGZpbGVEYXRhLndpZHRoID0gZGltZW5zaW9ucy53aWR0aFxuICAgICAgZmlsZURhdGEuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHRcbiAgICB9XG5cbiAgICBpZiAoc2hhcnBGaWxlKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHNoYXJwRmlsZS5tZXRhZGF0YSgpXG4gICAgICBmaWxlQnVmZmVyID0gYXdhaXQgc2hhcnBGaWxlLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSlcbiAgICAgIDsoeyBleHQsIG1pbWUgfSA9IGF3YWl0IGZyb21CdWZmZXIoZmlsZUJ1ZmZlci5kYXRhKSkgLy8gVGhpcyBpcyBnZXR0aW5nIGFuIGluY29ycmVjdCBnaWYgaGVpZ2h0IGJhY2suXG4gICAgICBmaWxlRGF0YS53aWR0aCA9IGZpbGVCdWZmZXIuaW5mby53aWR0aFxuICAgICAgZmlsZURhdGEuaGVpZ2h0ID0gZmlsZUJ1ZmZlci5pbmZvLmhlaWdodFxuICAgICAgZmlsZURhdGEuZmlsZXNpemUgPSBmaWxlQnVmZmVyLmluZm8uc2l6ZVxuXG4gICAgICAvLyBBbmltYXRlZCBHSUZzICsgV2ViUCBhZ2dyZWdhdGUgdGhlIGhlaWdodCBmcm9tIGV2ZXJ5IGZyYW1lLCBzbyB3ZSBuZWVkIHRvIHVzZSBkaXZpZGUgYnkgbnVtYmVyIG9mIHBhZ2VzXG4gICAgICBpZiAobWV0YWRhdGEucGFnZXMpIHtcbiAgICAgICAgZmlsZURhdGEuaGVpZ2h0ID0gZmlsZUJ1ZmZlci5pbmZvLmhlaWdodCAvIG1ldGFkYXRhLnBhZ2VzXG4gICAgICAgIGZpbGVEYXRhLmZpbGVzaXplID0gZmlsZUJ1ZmZlci5kYXRhLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtaW1lID0gZmlsZS5taW1ldHlwZVxuICAgICAgZmlsZURhdGEuZmlsZXNpemUgPSBmaWxlLnNpemVcblxuICAgICAgaWYgKGZpbGUubmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgIGV4dCA9IGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnNwbGl0KCc/JylbMF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dCA9ICcnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IFNWRyBtaW1lIHR5cGUuIGZyb21CdWZmZXIgbW9kaWZpZXMgaXQuXG4gICAgaWYgKG1pbWUgPT09ICdhcHBsaWNhdGlvbi94bWwnICYmIGV4dCA9PT0gJ3N2ZycpIG1pbWUgPSAnaW1hZ2Uvc3ZnK3htbCdcbiAgICBmaWxlRGF0YS5taW1lVHlwZSA9IG1pbWVcblxuICAgIGNvbnN0IGJhc2VGaWxlbmFtZSA9IHNhbml0aXplKGZpbGUubmFtZS5zdWJzdHJpbmcoMCwgZmlsZS5uYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IGZpbGUubmFtZSlcbiAgICBmc1NhZmVOYW1lID0gYCR7YmFzZUZpbGVuYW1lfSR7ZXh0ID8gYC4ke2V4dH1gIDogJyd9YFxuXG4gICAgaWYgKCFvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzKSB7XG4gICAgICBmc1NhZmVOYW1lID0gYXdhaXQgZ2V0U2FmZUZpbGVOYW1lKHtcbiAgICAgICAgY29sbGVjdGlvblNsdWc6IGNvbGxlY3Rpb25Db25maWcuc2x1ZyxcbiAgICAgICAgZGVzaXJlZEZpbGVuYW1lOiBmc1NhZmVOYW1lLFxuICAgICAgICByZXEsXG4gICAgICAgIHN0YXRpY1BhdGgsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZpbGVEYXRhLmZpbGVuYW1lID0gZnNTYWZlTmFtZVxuICAgIGxldCBmaWxlRm9yUmVzaXplID0gZmlsZVxuXG4gICAgaWYgKGNyb3BEYXRhKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGNyb3BwZWRJbWFnZSwgaW5mbyB9ID0gYXdhaXQgY3JvcEltYWdlKHsgY3JvcERhdGEsIGRpbWVuc2lvbnMsIGZpbGUgfSlcblxuICAgICAgZmlsZXNUb1NhdmUucHVzaCh7XG4gICAgICAgIGJ1ZmZlcjogY3JvcHBlZEltYWdlLFxuICAgICAgICBwYXRoOiBgJHtzdGF0aWNQYXRofS8ke2ZzU2FmZU5hbWV9YCxcbiAgICAgIH0pXG5cbiAgICAgIGZpbGVGb3JSZXNpemUgPSB7XG4gICAgICAgIC4uLmZpbGUsXG4gICAgICAgIGRhdGE6IGNyb3BwZWRJbWFnZSxcbiAgICAgICAgc2l6ZTogaW5mby5zaXplLFxuICAgICAgfVxuICAgICAgZmlsZURhdGEud2lkdGggPSBpbmZvLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBpbmZvLmhlaWdodFxuICAgICAgaWYgKGZpbGVJc0FuaW1hdGVkVHlwZSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHNoYXJwRmlsZS5tZXRhZGF0YSgpXG4gICAgICAgIGZpbGVEYXRhLmhlaWdodCA9IG1ldGFkYXRhLnBhZ2VzID8gaW5mby5oZWlnaHQgLyBtZXRhZGF0YS5wYWdlcyA6IGluZm8uaGVpZ2h0XG4gICAgICB9XG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGluZm8uc2l6ZVxuXG4gICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGZpbGUudGVtcEZpbGVQYXRoLCBjcm9wcGVkSW1hZ2UpIC8vIHdyaXRlIGZpbGVCdWZmZXIgdG8gdGhlIHRlbXAgcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLmZpbGVzLmZpbGUgPSBmaWxlRm9yUmVzaXplXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVzVG9TYXZlLnB1c2goe1xuICAgICAgICBidWZmZXI6IGZpbGVCdWZmZXI/LmRhdGEgfHwgZmlsZS5kYXRhLFxuICAgICAgICBwYXRoOiBgJHtzdGF0aWNQYXRofS8ke2ZzU2FmZU5hbWV9YCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIElmIHVzaW5nIHRlbXAgZmlsZXMgYW5kIHRoZSBpbWFnZSBpcyBiZWluZyByZXNpemVkLCB3cml0ZSB0aGUgZmlsZSB0byB0aGUgdGVtcCBwYXRoXG4gICAgICBpZiAoZmlsZUJ1ZmZlcj8uZGF0YSB8fCBmaWxlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoZmlsZS50ZW1wRmlsZVBhdGgsIGZpbGVCdWZmZXI/LmRhdGEgfHwgZmlsZS5kYXRhKSAvLyB3cml0ZSBmaWxlQnVmZmVyIHRvIHRoZSB0ZW1wIHBhdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBc3NpZ24gdGhlIF9wb3NzaWJseSBtb2RpZmllZF8gZmlsZSB0byB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICByZXEuZmlsZXMuZmlsZSA9IHtcbiAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICBkYXRhOiBmaWxlQnVmZmVyPy5kYXRhIHx8IGZpbGUuZGF0YSxcbiAgICAgICAgICAgIHNpemU6IGZpbGVCdWZmZXI/LmluZm8uc2l6ZSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlsZVN1cHBvcnRzUmVzaXplICYmIChBcnJheS5pc0FycmF5KGltYWdlU2l6ZXMpIHx8IGZvY2FsUG9pbnRFbmFibGVkICE9PSBmYWxzZSkpIHtcbiAgICAgIHJlcS5wYXlsb2FkVXBsb2FkU2l6ZXMgPSB7fVxuICAgICAgY29uc3QgeyBmb2NhbFBvaW50LCBzaXplRGF0YSwgc2l6ZXNUb1NhdmUgfSA9IGF3YWl0IHJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMoe1xuICAgICAgICBjb25maWc6IGNvbGxlY3Rpb25Db25maWcsXG4gICAgICAgIGRpbWVuc2lvbnM6ICFjcm9wRGF0YVxuICAgICAgICAgID8gZGltZW5zaW9uc1xuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGZpbGVEYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGZpbGVEYXRhLndpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgZmlsZTogZmlsZUZvclJlc2l6ZSxcbiAgICAgICAgbWltZVR5cGU6IGZpbGVEYXRhLm1pbWVUeXBlLFxuICAgICAgICByZXEsXG4gICAgICAgIHNhdmVkRmlsZW5hbWU6IGZzU2FmZU5hbWUgfHwgZmlsZS5uYW1lLFxuICAgICAgICBzdGF0aWNQYXRoLFxuICAgICAgICB1cGxvYWRFZGl0cyxcbiAgICAgIH0pXG5cbiAgICAgIGZpbGVEYXRhLnNpemVzID0gc2l6ZURhdGFcbiAgICAgIGZpbGVEYXRhLmZvY2FsWCA9IGZvY2FsUG9pbnQ/LnhcbiAgICAgIGZpbGVEYXRhLmZvY2FsWSA9IGZvY2FsUG9pbnQ/LnlcbiAgICAgIGZpbGVzVG9TYXZlLnB1c2goLi4uc2l6ZXNUb1NhdmUpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXEucGF5bG9hZC5sb2dnZXIuZXJyb3IoeyBlcnIsIG1zZzogJ0Vycm9yIHVwbG9hZGluZyBmaWxlJyB9KVxuICAgIHRocm93IG5ldyBGaWxlVXBsb2FkRXJyb3IocmVxLnQpXG4gIH1cblxuICBuZXdEYXRhID0ge1xuICAgIC4uLm5ld0RhdGEsXG4gICAgLi4uZmlsZURhdGEsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGE6IG5ld0RhdGEsXG4gICAgZmlsZXM6IGZpbGVzVG9TYXZlLFxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgdXBsb2FkIGVkaXRzIGZyb20gcmVxIG9yIGluY29taW5nIGRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VVcGxvYWRFZGl0c0Zyb21SZXFPckluY29taW5nRGF0YShhcmdzOiB7XG4gIGRhdGE6IHVua25vd25cbiAgb3BlcmF0aW9uOiAnY3JlYXRlJyB8ICd1cGRhdGUnXG4gIG9yaWdpbmFsRG9jOiB1bmtub3duXG4gIHJlcTogUGF5bG9hZFJlcXVlc3Rcbn0pOiBVcGxvYWRFZGl0cyB7XG4gIGNvbnN0IHsgZGF0YSwgb3BlcmF0aW9uLCBvcmlnaW5hbERvYywgcmVxIH0gPSBhcmdzXG5cbiAgLy8gR2V0IGludGVuZGVkIGZvY2FsIHBvaW50IGNoYW5nZSBmcm9tIHF1ZXJ5IHN0cmluZyBvciBpbmNvbWluZyBkYXRhXG4gIGNvbnN0IHVwbG9hZEVkaXRzID1cbiAgICByZXEucXVlcnk/LnVwbG9hZEVkaXRzICYmIHR5cGVvZiByZXEucXVlcnkudXBsb2FkRWRpdHMgPT09ICdvYmplY3QnXG4gICAgICA/IChyZXEucXVlcnkudXBsb2FkRWRpdHMgYXMgVXBsb2FkRWRpdHMpXG4gICAgICA6IHt9XG5cbiAgaWYgKHVwbG9hZEVkaXRzLmZvY2FsUG9pbnQpIHJldHVybiB1cGxvYWRFZGl0c1xuXG4gIGNvbnN0IGluY29taW5nRGF0YSA9IGRhdGEgYXMgRmlsZURhdGFcbiAgY29uc3Qgb3JpZ0RvYyA9IG9yaWdpbmFsRG9jIGFzIEZpbGVEYXRhXG5cbiAgLy8gSWYgbm8gY2hhbmdlIGluIGZvY2FsIHBvaW50LCByZXR1cm4gdW5kZWZpbmVkLlxuICAvLyBUaGlzIHByZXZlbnRzIGEgcmVmb2NhbCBvcGVyYXRpb24gdHJpZ2dlcmVkIGZyb20gYWRtaW4sIGJlY2F1c2UgaXQgYWx3YXlzIHNlbmRzIHRoZSBmb2NhbCBwb2ludC5cbiAgaWYgKG9yaWdEb2MgJiYgaW5jb21pbmdEYXRhLmZvY2FsWCA9PT0gb3JpZ0RvYy5mb2NhbFggJiYgaW5jb21pbmdEYXRhLmZvY2FsWSA9PT0gb3JpZ0RvYy5mb2NhbFkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoaW5jb21pbmdEYXRhLmZvY2FsWCAmJiBpbmNvbWluZ0RhdGEuZm9jYWxZKSB7XG4gICAgdXBsb2FkRWRpdHMuZm9jYWxQb2ludCA9IHtcbiAgICAgIHg6IGluY29taW5nRGF0YS5mb2NhbFgsXG4gICAgICB5OiBpbmNvbWluZ0RhdGEuZm9jYWxZLFxuICAgIH1cbiAgICByZXR1cm4gdXBsb2FkRWRpdHNcbiAgfVxuXG4gIC8vIElmIG5vIGZvY2FsIHBvaW50IGlzIHNldCwgZGVmYXVsdCB0byBjZW50ZXJcbiAgaWYgKG9wZXJhdGlvbiA9PT0gJ2NyZWF0ZScpIHtcbiAgICB1cGxvYWRFZGl0cy5mb2NhbFBvaW50ID0ge1xuICAgICAgeDogNTAsXG4gICAgICB5OiA1MCxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwbG9hZEVkaXRzXG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVGaWxlRGF0YSIsImNvbGxlY3Rpb24iLCJjb25maWciLCJjb2xsZWN0aW9uQ29uZmlnIiwiZGF0YSIsIm9wZXJhdGlvbiIsIm9yaWdpbmFsRG9jIiwib3ZlcndyaXRlRXhpc3RpbmdGaWxlcyIsInJlcSIsInRocm93T25NaXNzaW5nRmlsZSIsInVwbG9hZCIsImZpbGVzIiwiZmlsZSIsInVuZGVmaW5lZCIsInVwbG9hZEVkaXRzIiwicGFyc2VVcGxvYWRFZGl0c0Zyb21SZXFPckluY29taW5nRGF0YSIsImRpc2FibGVMb2NhbFN0b3JhZ2UiLCJmb2NhbFBvaW50IiwiZm9jYWxQb2ludEVuYWJsZWQiLCJmb3JtYXRPcHRpb25zIiwiaW1hZ2VTaXplcyIsInJlc2l6ZU9wdGlvbnMiLCJzdGF0aWNEaXIiLCJ0cmltT3B0aW9ucyIsInN0YXRpY1BhdGgiLCJpbmRleE9mIiwicGF0aCIsInJlc29sdmUiLCJwYXRocyIsImNvbmZpZ0RpciIsImZpbGVuYW1lIiwidXJsIiwic3RhcnRzV2l0aCIsImZpbGVQYXRoIiwicmVzcG9uc2UiLCJnZXRGaWxlQnlQYXRoIiwiZ2V0RXh0ZXJuYWxGaWxlIiwidXBsb2FkQ29uZmlnIiwiZXJyIiwiRXJyb3IiLCJGaWxlUmV0cmlldmFsRXJyb3IiLCJ0IiwibWVzc2FnZSIsIk1pc3NpbmdGaWxlIiwibWtkaXJwIiwic3luYyIsIm5ld0RhdGEiLCJmaWxlc1RvU2F2ZSIsImZpbGVEYXRhIiwiZmlsZUlzQW5pbWF0ZWRUeXBlIiwiaW5jbHVkZXMiLCJtaW1ldHlwZSIsImNyb3BEYXRhIiwiY3JvcCIsImZpbGVTdXBwb3J0c1Jlc2l6ZSIsImNhblJlc2l6ZUltYWdlIiwiZnNTYWZlTmFtZSIsInNoYXJwRmlsZSIsImRpbWVuc2lvbnMiLCJmaWxlQnVmZmVyIiwiZXh0IiwibWltZSIsImZpbGVIYXNBZGp1c3RtZW50cyIsIkJvb2xlYW4iLCJ0ZW1wRmlsZVBhdGgiLCJzaGFycE9wdGlvbnMiLCJhbmltYXRlZCIsInNoYXJwIiwicm90YXRlIiwicmVzaXplIiwidG9Gb3JtYXQiLCJmb3JtYXQiLCJvcHRpb25zIiwidHJpbSIsImlzSW1hZ2UiLCJnZXRJbWFnZVNpemUiLCJ3aWR0aCIsImhlaWdodCIsIm1ldGFkYXRhIiwidG9CdWZmZXIiLCJyZXNvbHZlV2l0aE9iamVjdCIsImZyb21CdWZmZXIiLCJpbmZvIiwiZmlsZXNpemUiLCJzaXplIiwicGFnZXMiLCJsZW5ndGgiLCJuYW1lIiwic3BsaXQiLCJwb3AiLCJtaW1lVHlwZSIsImJhc2VGaWxlbmFtZSIsInNhbml0aXplIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJnZXRTYWZlRmlsZU5hbWUiLCJjb2xsZWN0aW9uU2x1ZyIsInNsdWciLCJkZXNpcmVkRmlsZW5hbWUiLCJmaWxlRm9yUmVzaXplIiwiY3JvcHBlZEltYWdlIiwiY3JvcEltYWdlIiwicHVzaCIsImJ1ZmZlciIsImZzIiwicHJvbWlzZXMiLCJ3cml0ZUZpbGUiLCJBcnJheSIsImlzQXJyYXkiLCJwYXlsb2FkVXBsb2FkU2l6ZXMiLCJzaXplRGF0YSIsInNpemVzVG9TYXZlIiwicmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyIsInNhdmVkRmlsZW5hbWUiLCJzaXplcyIsImZvY2FsWCIsIngiLCJmb2NhbFkiLCJ5IiwicGF5bG9hZCIsImxvZ2dlciIsImVycm9yIiwibXNnIiwiRmlsZVVwbG9hZEVycm9yIiwiYXJncyIsInF1ZXJ5IiwiaW5jb21pbmdEYXRhIiwib3JpZ0RvYyJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7OytCQTBDYUE7OztlQUFBQTs7OzBCQXZDYzsyREFDWjsrREFDSTs2REFDRjt5RUFDSTs4REFDSDt3QkFPMkI7MkVBQ2Q7dUVBQ0o7a0VBQ0w7aUNBQ1U7c0VBQ047cUVBQ0Q7d0VBQ0c7cUVBQ2E7Z0VBQ3JCOzs7Ozs7QUFrQmIsTUFBTUEsbUJBQW1CLE9BQVUsRUFDeENDLFlBQVksRUFBRUMsUUFBUUMsZ0JBQWdCLEVBQUUsRUFDeENELE1BQU0sRUFDTkUsSUFBSSxFQUNKQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsc0JBQXNCLEVBQ3RCQyxHQUFHLEVBQ0hDLGtCQUFrQixFQUNWO0lBQ1IsSUFBSSxDQUFDTixpQkFBaUJPLE1BQU0sRUFBRTtRQUM1QixPQUFPO1lBQ0xOO1lBQ0FPLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxJQUFJQyxPQUFPSixJQUFJRyxLQUFLLEVBQUVDLFFBQVFDO0lBRTlCLE1BQU1DLGNBQWNDLHNDQUFzQztRQUN4RFg7UUFDQUM7UUFDQUM7UUFDQUU7SUFDRjtJQUVBLE1BQU0sRUFDSlEsbUJBQW1CLEVBQ25CQyxZQUFZQyxpQkFBaUIsRUFDN0JDLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsV0FBVyxFQUNaLEdBQUdwQixpQkFBaUJPLE1BQU07SUFFM0IsSUFBSWMsYUFBYUY7SUFDakIsSUFBSUEsVUFBVUcsT0FBTyxDQUFDLFNBQVMsR0FBRztRQUNoQ0QsYUFBYUUsYUFBSSxDQUFDQyxPQUFPLENBQUN6QixPQUFPMEIsS0FBSyxDQUFDQyxTQUFTLEVBQUVQO0lBQ3BEO0lBRUEsSUFBSSxDQUFDVixRQUFRRSxlQUFlVixNQUFNO1FBQ2hDLE1BQU0sRUFBRTBCLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEdBQUczQjtRQUUxQixJQUFJO1lBQ0YsSUFBSTJCLE9BQU9BLElBQUlDLFVBQVUsQ0FBQyxRQUFRLENBQUNoQixxQkFBcUI7Z0JBQ3RELE1BQU1pQixXQUFXLENBQUMsRUFBRVQsV0FBVyxDQUFDLEVBQUVNLFNBQVMsQ0FBQztnQkFDNUMsTUFBTUksV0FBVyxNQUFNQyxJQUFBQSxzQkFBYSxFQUFDRjtnQkFDckNyQixPQUFPc0I7Z0JBQ1AzQix5QkFBeUI7WUFDM0IsT0FBTyxJQUFJdUIsWUFBWUMsS0FBSztnQkFDMUJuQixPQUFRLE1BQU13QixJQUFBQSxnQ0FBZSxFQUFDO29CQUM1QmhDLE1BQU1BO29CQUNOSTtvQkFDQTZCLGNBQWNsQyxpQkFBaUJPLE1BQU07Z0JBQ3ZDO2dCQUNBSCx5QkFBeUI7WUFDM0I7UUFDRixFQUFFLE9BQU8rQixLQUFjO1lBQ3JCLElBQUlBLGVBQWVDLE9BQU87Z0JBQ3hCLE1BQU0sSUFBSUMsMkJBQWtCLENBQUNoQyxJQUFJaUMsQ0FBQyxFQUFFSCxJQUFJSSxPQUFPO1lBQ2pEO1FBQ0Y7SUFDRjtJQUVBLElBQUksQ0FBQzlCLE1BQU07UUFDVCxJQUFJSCxvQkFBb0IsTUFBTSxJQUFJa0MsbUJBQVcsQ0FBQ25DLElBQUlpQyxDQUFDO1FBRW5ELE9BQU87WUFDTHJDO1lBQ0FPLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxJQUFJLENBQUNLLHFCQUFxQjtRQUN4QjRCLGVBQU0sQ0FBQ0MsSUFBSSxDQUFDckI7SUFDZDtJQUVBLElBQUlzQixVQUFVMUM7SUFDZCxNQUFNMkMsY0FBNEIsRUFBRTtJQUNwQyxNQUFNQyxXQUE4QixDQUFDO0lBQ3JDLE1BQU1DLHFCQUFxQjtRQUFDO1FBQWM7UUFBYTtLQUFhLENBQUNDLFFBQVEsQ0FBQ3RDLEtBQUt1QyxRQUFRO0lBQzNGLE1BQU1DLFdBQ0osT0FBT3RDLGdCQUFnQixZQUFZLFVBQVVBLGNBQWNBLFlBQVl1QyxJQUFJLEdBQUd4QztJQUVoRixJQUFJO1FBQ0YsTUFBTXlDLHFCQUFxQkMsSUFBQUEsdUJBQWMsRUFBQzNDLEtBQUt1QyxRQUFRO1FBQ3ZELElBQUlLO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLE1BQU1DLHFCQUNKUixzQkFDQVMsUUFBUTFDLGlCQUFpQkYsaUJBQWlCQyxjQUFjRyxlQUFlWCxLQUFLb0QsWUFBWTtRQUUxRixNQUFNQyxlQUE2QixDQUFDO1FBRXBDLElBQUloQixvQkFBb0JnQixhQUFhQyxRQUFRLEdBQUc7UUFFaEQsSUFBSUMsY0FBSyxJQUFLbEIsQ0FBQUEsc0JBQXNCYSxrQkFBaUIsR0FBSTtZQUN2RCxJQUFJbEQsS0FBS29ELFlBQVksRUFBRTtnQkFDckJQLFlBQVlVLElBQUFBLGNBQUssRUFBQ3ZELEtBQUtvRCxZQUFZLEVBQUVDLGNBQWNHLE1BQU0sR0FBRyxtR0FBbUc7O1lBQ2pLLE9BQU87Z0JBQ0xYLFlBQVlVLElBQUFBLGNBQUssRUFBQ3ZELEtBQUtSLElBQUksRUFBRTZELGNBQWNHLE1BQU0sR0FBRyxtR0FBbUc7O1lBQ3pKO1lBRUEsSUFBSU4sb0JBQW9CO2dCQUN0QixJQUFJekMsZUFBZTtvQkFDakJvQyxZQUFZQSxVQUFVWSxNQUFNLENBQUNoRDtnQkFDL0I7Z0JBQ0EsSUFBSUYsZUFBZTtvQkFDakJzQyxZQUFZQSxVQUFVYSxRQUFRLENBQUNuRCxjQUFjb0QsTUFBTSxFQUFFcEQsY0FBY3FELE9BQU87Z0JBQzVFO2dCQUNBLElBQUlqRCxhQUFhO29CQUNma0MsWUFBWUEsVUFBVWdCLElBQUksQ0FBQ2xEO2dCQUM3QjtZQUNGO1FBQ0Y7UUFFQSxJQUFJK0Isc0JBQXNCb0IsSUFBQUEsZ0JBQU8sRUFBQzlELEtBQUt1QyxRQUFRLEdBQUc7WUFDaERPLGFBQWEsTUFBTWlCLElBQUFBLHFCQUFZLEVBQUMvRDtZQUNoQ29DLFNBQVM0QixLQUFLLEdBQUdsQixXQUFXa0IsS0FBSztZQUNqQzVCLFNBQVM2QixNQUFNLEdBQUduQixXQUFXbUIsTUFBTTtRQUNyQztRQUVBLElBQUlwQixXQUFXO1lBQ2IsTUFBTXFCLFdBQVcsTUFBTXJCLFVBQVVxQixRQUFRO1lBQ3pDbkIsYUFBYSxNQUFNRixVQUFVc0IsUUFBUSxDQUFDO2dCQUFFQyxtQkFBbUI7WUFBSztZQUM5RCxDQUFBLEVBQUVwQixHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHLE1BQU1vQixJQUFBQSxvQkFBVSxFQUFDdEIsV0FBV3ZELElBQUksRUFBRyxnREFBZ0Q7WUFBbkQ7WUFDbEQ0QyxTQUFTNEIsS0FBSyxHQUFHakIsV0FBV3VCLElBQUksQ0FBQ04sS0FBSztZQUN0QzVCLFNBQVM2QixNQUFNLEdBQUdsQixXQUFXdUIsSUFBSSxDQUFDTCxNQUFNO1lBQ3hDN0IsU0FBU21DLFFBQVEsR0FBR3hCLFdBQVd1QixJQUFJLENBQUNFLElBQUk7WUFFeEMsMEdBQTBHO1lBQzFHLElBQUlOLFNBQVNPLEtBQUssRUFBRTtnQkFDbEJyQyxTQUFTNkIsTUFBTSxHQUFHbEIsV0FBV3VCLElBQUksQ0FBQ0wsTUFBTSxHQUFHQyxTQUFTTyxLQUFLO2dCQUN6RHJDLFNBQVNtQyxRQUFRLEdBQUd4QixXQUFXdkQsSUFBSSxDQUFDa0YsTUFBTTtZQUM1QztRQUNGLE9BQU87WUFDTHpCLE9BQU9qRCxLQUFLdUMsUUFBUTtZQUNwQkgsU0FBU21DLFFBQVEsR0FBR3ZFLEtBQUt3RSxJQUFJO1lBRTdCLElBQUl4RSxLQUFLMkUsSUFBSSxDQUFDckMsUUFBUSxDQUFDLE1BQU07Z0JBQzNCVSxNQUFNaEQsS0FBSzJFLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEtBQUtDLEdBQUcsR0FBR0QsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hELE9BQU87Z0JBQ0w1QixNQUFNO1lBQ1I7UUFDRjtRQUVBLGdEQUFnRDtRQUNoRCxJQUFJQyxTQUFTLHFCQUFxQkQsUUFBUSxPQUFPQyxPQUFPO1FBQ3hEYixTQUFTMEMsUUFBUSxHQUFHN0I7UUFFcEIsTUFBTThCLGVBQWVDLElBQUFBLHlCQUFRLEVBQUNoRixLQUFLMkUsSUFBSSxDQUFDTSxTQUFTLENBQUMsR0FBR2pGLEtBQUsyRSxJQUFJLENBQUNPLFdBQVcsQ0FBQyxTQUFTbEYsS0FBSzJFLElBQUk7UUFDN0YvQixhQUFhLENBQUMsRUFBRW1DLGFBQWEsRUFBRS9CLE1BQU0sQ0FBQyxDQUFDLEVBQUVBLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUVyRCxJQUFJLENBQUNyRCx3QkFBd0I7WUFDM0JpRCxhQUFhLE1BQU11QyxJQUFBQSx3QkFBZSxFQUFDO2dCQUNqQ0MsZ0JBQWdCN0YsaUJBQWlCOEYsSUFBSTtnQkFDckNDLGlCQUFpQjFDO2dCQUNqQmhEO2dCQUNBZ0I7WUFDRjtRQUNGO1FBRUF3QixTQUFTbEIsUUFBUSxHQUFHMEI7UUFDcEIsSUFBSTJDLGdCQUFnQnZGO1FBRXBCLElBQUl3QyxVQUFVO1lBQ1osTUFBTSxFQUFFaEQsTUFBTWdHLFlBQVksRUFBRWxCLElBQUksRUFBRSxHQUFHLE1BQU1tQixJQUFBQSxrQkFBUyxFQUFDO2dCQUFFakQ7Z0JBQVVNO2dCQUFZOUM7WUFBSztZQUVsRm1DLFlBQVl1RCxJQUFJLENBQUM7Z0JBQ2ZDLFFBQVFIO2dCQUNSMUUsTUFBTSxDQUFDLEVBQUVGLFdBQVcsQ0FBQyxFQUFFZ0MsV0FBVyxDQUFDO1lBQ3JDO1lBRUEyQyxnQkFBZ0I7Z0JBQ2QsR0FBR3ZGLElBQUk7Z0JBQ1BSLE1BQU1nRztnQkFDTmhCLE1BQU1GLEtBQUtFLElBQUk7WUFDakI7WUFDQXBDLFNBQVM0QixLQUFLLEdBQUdNLEtBQUtOLEtBQUs7WUFDM0I1QixTQUFTNkIsTUFBTSxHQUFHSyxLQUFLTCxNQUFNO1lBQzdCLElBQUk1QixvQkFBb0I7Z0JBQ3RCLE1BQU02QixXQUFXLE1BQU1yQixVQUFVcUIsUUFBUTtnQkFDekM5QixTQUFTNkIsTUFBTSxHQUFHQyxTQUFTTyxLQUFLLEdBQUdILEtBQUtMLE1BQU0sR0FBR0MsU0FBU08sS0FBSyxHQUFHSCxLQUFLTCxNQUFNO1lBQy9FO1lBQ0E3QixTQUFTbUMsUUFBUSxHQUFHRCxLQUFLRSxJQUFJO1lBRTdCLElBQUl4RSxLQUFLb0QsWUFBWSxFQUFFO2dCQUNyQixNQUFNd0MsV0FBRSxDQUFDQyxRQUFRLENBQUNDLFNBQVMsQ0FBQzlGLEtBQUtvRCxZQUFZLEVBQUVvQyxjQUFjLG9DQUFvQzs7WUFDbkcsT0FBTztnQkFDTDVGLElBQUlHLEtBQUssQ0FBQ0MsSUFBSSxHQUFHdUY7WUFDbkI7UUFDRixPQUFPO1lBQ0xwRCxZQUFZdUQsSUFBSSxDQUFDO2dCQUNmQyxRQUFRNUMsWUFBWXZELFFBQVFRLEtBQUtSLElBQUk7Z0JBQ3JDc0IsTUFBTSxDQUFDLEVBQUVGLFdBQVcsQ0FBQyxFQUFFZ0MsV0FBVyxDQUFDO1lBQ3JDO1lBRUEsc0ZBQXNGO1lBQ3RGLElBQUlHLFlBQVl2RCxRQUFRUSxLQUFLUixJQUFJLENBQUNrRixNQUFNLEdBQUcsR0FBRztnQkFDNUMsSUFBSTFFLEtBQUtvRCxZQUFZLEVBQUU7b0JBQ3JCLE1BQU13QyxXQUFFLENBQUNDLFFBQVEsQ0FBQ0MsU0FBUyxDQUFDOUYsS0FBS29ELFlBQVksRUFBRUwsWUFBWXZELFFBQVFRLEtBQUtSLElBQUksRUFBRSxvQ0FBb0M7O2dCQUNwSCxPQUFPO29CQUNMLDREQUE0RDtvQkFDNURJLElBQUlHLEtBQUssQ0FBQ0MsSUFBSSxHQUFHO3dCQUNmLEdBQUdBLElBQUk7d0JBQ1BSLE1BQU11RCxZQUFZdkQsUUFBUVEsS0FBS1IsSUFBSTt3QkFDbkNnRixNQUFNekIsWUFBWXVCLEtBQUtFO29CQUN6QjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJOUIsc0JBQXVCcUQsQ0FBQUEsTUFBTUMsT0FBTyxDQUFDeEYsZUFBZUYsc0JBQXNCLEtBQUksR0FBSTtZQUNwRlYsSUFBSXFHLGtCQUFrQixHQUFHLENBQUM7WUFDMUIsTUFBTSxFQUFFNUYsVUFBVSxFQUFFNkYsUUFBUSxFQUFFQyxXQUFXLEVBQUUsR0FBRyxNQUFNQyxJQUFBQSxxQkFBNEIsRUFBQztnQkFDL0U5RyxRQUFRQztnQkFDUnVELFlBQVksQ0FBQ04sV0FDVE0sYUFDQTtvQkFDRSxHQUFHQSxVQUFVO29CQUNibUIsUUFBUTdCLFNBQVM2QixNQUFNO29CQUN2QkQsT0FBTzVCLFNBQVM0QixLQUFLO2dCQUN2QjtnQkFDSmhFLE1BQU11RjtnQkFDTlQsVUFBVTFDLFNBQVMwQyxRQUFRO2dCQUMzQmxGO2dCQUNBeUcsZUFBZXpELGNBQWM1QyxLQUFLMkUsSUFBSTtnQkFDdEMvRDtnQkFDQVY7WUFDRjtZQUVBa0MsU0FBU2tFLEtBQUssR0FBR0o7WUFDakI5RCxTQUFTbUUsTUFBTSxHQUFHbEcsWUFBWW1HO1lBQzlCcEUsU0FBU3FFLE1BQU0sR0FBR3BHLFlBQVlxRztZQUM5QnZFLFlBQVl1RCxJQUFJLElBQUlTO1FBQ3RCO0lBQ0YsRUFBRSxPQUFPekUsS0FBSztRQUNaOUIsSUFBSStHLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDQyxLQUFLLENBQUM7WUFBRW5GO1lBQUtvRixLQUFLO1FBQXVCO1FBQzVELE1BQU0sSUFBSUMsdUJBQWUsQ0FBQ25ILElBQUlpQyxDQUFDO0lBQ2pDO0lBRUFLLFVBQVU7UUFDUixHQUFHQSxPQUFPO1FBQ1YsR0FBR0UsUUFBUTtJQUNiO0lBRUEsT0FBTztRQUNMNUMsTUFBTTBDO1FBQ05uQyxPQUFPb0M7SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTaEMsc0NBQXNDNkcsSUFLOUM7SUFDQyxNQUFNLEVBQUV4SCxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFRSxHQUFHLEVBQUUsR0FBR29IO0lBRTlDLHFFQUFxRTtJQUNyRSxNQUFNOUcsY0FDSk4sSUFBSXFILEtBQUssRUFBRS9HLGVBQWUsT0FBT04sSUFBSXFILEtBQUssQ0FBQy9HLFdBQVcsS0FBSyxXQUN0RE4sSUFBSXFILEtBQUssQ0FBQy9HLFdBQVcsR0FDdEIsQ0FBQztJQUVQLElBQUlBLFlBQVlHLFVBQVUsRUFBRSxPQUFPSDtJQUVuQyxNQUFNZ0gsZUFBZTFIO0lBQ3JCLE1BQU0ySCxVQUFVekg7SUFFaEIsaURBQWlEO0lBQ2pELG1HQUFtRztJQUNuRyxJQUFJeUgsV0FBV0QsYUFBYVgsTUFBTSxLQUFLWSxRQUFRWixNQUFNLElBQUlXLGFBQWFULE1BQU0sS0FBS1UsUUFBUVYsTUFBTSxFQUFFO1FBQy9GLE9BQU94RztJQUNUO0lBRUEsSUFBSWlILGFBQWFYLE1BQU0sSUFBSVcsYUFBYVQsTUFBTSxFQUFFO1FBQzlDdkcsWUFBWUcsVUFBVSxHQUFHO1lBQ3ZCbUcsR0FBR1UsYUFBYVgsTUFBTTtZQUN0QkcsR0FBR1EsYUFBYVQsTUFBTTtRQUN4QjtRQUNBLE9BQU92RztJQUNUO0lBRUEsOENBQThDO0lBQzlDLElBQUlULGNBQWMsVUFBVTtRQUMxQlMsWUFBWUcsVUFBVSxHQUFHO1lBQ3ZCbUcsR0FBRztZQUNIRSxHQUFHO1FBQ0w7SUFDRjtJQUNBLE9BQU94RztBQUNUIn0=