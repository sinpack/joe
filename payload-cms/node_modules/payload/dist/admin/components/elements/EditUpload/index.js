"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "EditUpload", {
    enumerable: true,
    get: function() {
        return EditUpload;
    }
});
const _modal = require("@faceless-ui/modal");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _reactimagecrop = /*#__PURE__*/ _interop_require_default(require("react-image-crop"));
require("react-image-crop/dist/ReactCrop.css");
const _Plus = /*#__PURE__*/ _interop_require_default(require("../../icons/Plus"));
const _UploadEdits = require("../../utilities/UploadEdits");
const _Upload = require("../../views/collections/Edit/Upload");
const _Button = /*#__PURE__*/ _interop_require_default(require("../Button"));
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'edit-upload';
const Input = /*#__PURE__*/ (0, _react.forwardRef)((props, ref)=>{
    const { name, onChange, value } = props;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__input`
    }, name, /*#__PURE__*/ _react.default.createElement("input", {
        name: name,
        onChange: (e)=>onChange(e.target.value),
        ref: ref,
        type: "number",
        value: value
    }));
});
const EditUpload = ({ doc, fileName, fileSrc, imageCacheTag, showCrop, showFocalPoint })=>{
    const { closeModal } = (0, _modal.useModal)();
    const { t } = (0, _reacti18next.useTranslation)([
        'general',
        'upload'
    ]);
    const { updateUploadEdits, uploadEdits } = (0, _UploadEdits.useUploadEdits)();
    const [focalPosition, setFocalPosition] = (0, _react.useState)({
        x: uploadEdits?.focalPoint?.x || doc.focalX || 50,
        y: uploadEdits?.focalPoint?.y || doc.focalY || 50
    });
    const [checkBounds, setCheckBounds] = (0, _react.useState)(false);
    const [originalHeight, setOriginalHeight] = (0, _react.useState)(0);
    const [originalWidth, setOriginalWidth] = (0, _react.useState)(0);
    const focalWrapRef = (0, _react.useRef)();
    const imageRef = (0, _react.useRef)();
    const cropRef = (0, _react.useRef)();
    const heightRef = (0, _react.useRef)(null);
    const widthRef = (0, _react.useRef)(null);
    const [crop, setCrop] = (0, _react.useState)({
        height: 100,
        heightPixels: 0,
        unit: '%',
        width: 100,
        widthPixels: 0,
        x: 0,
        y: 0
    });
    const [imageLoaded, setImageLoaded] = (0, _react.useState)(false);
    const onImageLoad = (e)=>{
        setOriginalHeight(e.currentTarget.naturalHeight);
        setOriginalWidth(e.currentTarget.naturalWidth);
        setImageLoaded(true);
    };
    const fineTuneCrop = ({ dimension, value })=>{
        const intValue = parseInt(value);
        if (dimension === 'width' && intValue >= originalWidth) return null;
        if (dimension === 'height' && intValue >= originalHeight) return null;
        const percentage = 100 * (intValue / (dimension === 'width' ? originalWidth : originalHeight));
        if (percentage === 100 || percentage === 0) return null;
        setCrop({
            ...crop,
            [dimension]: percentage
        });
    };
    const fineTuneFocalPosition = ({ coordinate, value })=>{
        const intValue = parseInt(value);
        if (intValue >= 0 && intValue <= 100) {
            setFocalPosition((prevPosition)=>({
                    ...prevPosition,
                    [coordinate]: intValue
                }));
        }
    };
    const saveEdits = ()=>{
        updateUploadEdits({
            crop: crop ? {
                ...crop,
                heightPixels: Number(heightRef.current?.value ?? crop.heightPixels),
                widthPixels: Number(widthRef.current?.value ?? crop.widthPixels)
            } : undefined,
            focalPoint: focalPosition ? focalPosition : undefined
        });
        closeModal(_Upload.editDrawerSlug);
    };
    const onDragEnd = _react.default.useCallback(({ x, y })=>{
        setFocalPosition({
            x,
            y
        });
        setCheckBounds(false);
    }, []);
    const centerFocalPoint = ()=>{
        const containerRect = focalWrapRef.current.getBoundingClientRect();
        const boundsRect = showCrop ? cropRef.current.getBoundingClientRect() : imageRef.current.getBoundingClientRect();
        const xCenter = (boundsRect.left - containerRect.left + boundsRect.width / 2) / containerRect.width * 100;
        const yCenter = (boundsRect.top - containerRect.top + boundsRect.height / 2) / containerRect.height * 100;
        setFocalPosition({
            x: xCenter,
            y: yCenter
        });
    };
    const fileSrcToUse = imageCacheTag ? `${fileSrc}?${imageCacheTag}` : fileSrc;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: baseClass
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__header`
    }, /*#__PURE__*/ _react.default.createElement("h2", {
        title: `${t('general:editing')} ${fileName}`
    }, t('general:editing'), " ", fileName), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__actions`
    }, /*#__PURE__*/ _react.default.createElement(_Button.default, {
        "aria-label": t('cancel'),
        buttonStyle: "secondary",
        className: `${baseClass}__cancel`,
        onClick: ()=>closeModal(_Upload.editDrawerSlug)
    }, t('general:cancel')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        "aria-label": t('general:applyChanges'),
        buttonStyle: "primary",
        className: `${baseClass}__save`,
        disabled: !imageLoaded,
        onClick: ()=>saveEdits()
    }, t('general:applyChanges')))), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__toolWrap`
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__crop`
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__focal-wrapper`,
        ref: focalWrapRef,
        style: {
            aspectRatio: `${originalWidth / originalHeight}`
        }
    }, showCrop ? /*#__PURE__*/ _react.default.createElement(_reactimagecrop.default, {
        className: `${baseClass}__reactCrop`,
        crop: crop,
        onChange: (_, c)=>setCrop(c),
        onComplete: ()=>setCheckBounds(true),
        renderSelectionAddon: ()=>{
            return /*#__PURE__*/ _react.default.createElement("div", {
                className: `${baseClass}__crop-window`,
                ref: cropRef
            });
        }
    }, /*#__PURE__*/ _react.default.createElement("img", {
        alt: t('upload:setCropArea'),
        onLoad: onImageLoad,
        ref: imageRef,
        src: fileSrcToUse
    })) : /*#__PURE__*/ _react.default.createElement("img", {
        alt: t('upload:setFocalPoint'),
        onLoad: onImageLoad,
        ref: imageRef,
        src: fileSrcToUse
    }), showFocalPoint && /*#__PURE__*/ _react.default.createElement(DraggableElement, {
        boundsRef: showCrop ? cropRef : imageRef,
        checkBounds: showCrop ? checkBounds : false,
        className: `${baseClass}__focalPoint`,
        containerRef: focalWrapRef,
        initialPosition: focalPosition,
        onDragEnd: onDragEnd,
        setCheckBounds: showCrop ? setCheckBounds : false
    }, /*#__PURE__*/ _react.default.createElement(_Plus.default, null)))), (showCrop || showFocalPoint) && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__sidebar`
    }, showCrop && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__groupWrap`
    }, /*#__PURE__*/ _react.default.createElement("div", null, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__titleWrap`
    }, /*#__PURE__*/ _react.default.createElement("h3", null, t('upload:crop')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "none",
        className: `${baseClass}__reset`,
        onClick: ()=>setCrop({
                height: 100,
                heightPixels: originalHeight,
                unit: '%',
                width: 100,
                widthPixels: originalWidth,
                x: 0,
                y: 0
            })
    }, t('general:reset')))), /*#__PURE__*/ _react.default.createElement("span", {
        className: `${baseClass}__description`
    }, t('upload:cropToolDescription')), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__inputsWrap`
    }, /*#__PURE__*/ _react.default.createElement(Input, {
        name: `${t('upload:width')} (px)`,
        onChange: (value)=>fineTuneCrop({
                dimension: 'width',
                value
            }),
        ref: widthRef,
        value: (crop.width / 100 * originalWidth).toFixed(0)
    }), /*#__PURE__*/ _react.default.createElement(Input, {
        name: `${t('upload:height')} (px)`,
        onChange: (value)=>fineTuneCrop({
                dimension: 'height',
                value
            }),
        ref: heightRef,
        value: (crop.height / 100 * originalHeight).toFixed(0)
    }))), showFocalPoint && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__groupWrap`
    }, /*#__PURE__*/ _react.default.createElement("div", null, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__titleWrap`
    }, /*#__PURE__*/ _react.default.createElement("h3", null, t('upload:focalPoint')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "none",
        className: `${baseClass}__reset`,
        onClick: centerFocalPoint
    }, t('general:reset')))), /*#__PURE__*/ _react.default.createElement("span", {
        className: `${baseClass}__description`
    }, t('upload:focalPointDescription')), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__inputsWrap`
    }, /*#__PURE__*/ _react.default.createElement(Input, {
        name: "X %",
        onChange: (value)=>fineTuneFocalPosition({
                coordinate: 'x',
                value
            }),
        value: focalPosition.x.toFixed(0)
    }), /*#__PURE__*/ _react.default.createElement(Input, {
        name: "Y %",
        onChange: (value)=>fineTuneFocalPosition({
                coordinate: 'y',
                value
            }),
        value: focalPosition.y.toFixed(0)
    }))))));
};
const DraggableElement = ({ boundsRef, checkBounds, children, className, containerRef, initialPosition = {
    x: 50,
    y: 50
}, onDragEnd, setCheckBounds })=>{
    const [position, setPosition] = (0, _react.useState)({
        x: initialPosition.x,
        y: initialPosition.y
    });
    const [isDragging, setIsDragging] = (0, _react.useState)(false);
    const dragRef = (0, _react.useRef)();
    const getCoordinates = _react.default.useCallback((mouseXArg, mouseYArg, recenter)=>{
        const containerRect = containerRef.current.getBoundingClientRect();
        const boundsRect = boundsRef.current.getBoundingClientRect();
        const mouseX = mouseXArg ?? boundsRect.left;
        const mouseY = mouseYArg ?? boundsRect.top;
        const xOutOfBounds = mouseX < boundsRect.left || mouseX > boundsRect.right;
        const yOutOfBounds = mouseY < boundsRect.top || mouseY > boundsRect.bottom;
        let x = (mouseX - containerRect.left) / containerRect.width * 100;
        let y = (mouseY - containerRect.top) / containerRect.height * 100;
        const xCenter = (boundsRect.left - containerRect.left + boundsRect.width / 2) / containerRect.width * 100;
        const yCenter = (boundsRect.top - containerRect.top + boundsRect.height / 2) / containerRect.height * 100;
        if (xOutOfBounds || yOutOfBounds) {
            setIsDragging(false);
            if (mouseX < boundsRect.left) {
                x = (boundsRect.left - containerRect.left) / containerRect.width * 100;
            } else if (mouseX > boundsRect.right) {
                x = (containerRect.width - (containerRect.right - boundsRect.right)) / containerRect.width * 100;
            }
            if (mouseY < boundsRect.top) {
                y = (boundsRect.top - containerRect.top) / containerRect.height * 100;
            } else if (mouseY > boundsRect.bottom) {
                y = (containerRect.height - (containerRect.bottom - boundsRect.bottom)) / containerRect.height * 100;
            }
            if (recenter) {
                x = xOutOfBounds ? xCenter : x;
                y = yOutOfBounds ? yCenter : y;
            }
        }
        return {
            x,
            y
        };
    }, [
        boundsRef,
        containerRef
    ]);
    const handleMouseDown = (event)=>{
        event.preventDefault();
        setIsDragging(true);
    };
    const handleMouseMove = (event)=>{
        if (!isDragging) return null;
        const { x, y } = getCoordinates(event.clientX, event.clientY);
        setPosition({
            x,
            y
        });
    };
    const onDrop = ()=>{
        setIsDragging(false);
        onDragEnd(position);
    };
    _react.default.useEffect(()=>{
        if (isDragging || !dragRef.current) return;
        if (checkBounds) {
            const { height, left, top, width } = dragRef.current.getBoundingClientRect();
            const { x, y } = getCoordinates(left + width / 2, top + height / 2, true);
            onDragEnd({
                x,
                y
            });
            setPosition({
                x,
                y
            });
            setCheckBounds(false);
            return;
        }
    }, [
        getCoordinates,
        isDragging,
        checkBounds,
        setCheckBounds,
        position.x,
        position.y,
        onDragEnd
    ]);
    _react.default.useEffect(()=>{
        setPosition({
            x: initialPosition.x,
            y: initialPosition.y
        });
    }, [
        initialPosition.x,
        initialPosition.y
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            `${baseClass}__draggable-container`,
            isDragging && `${baseClass}__draggable-container--dragging`
        ].filter(Boolean).join(' '),
        onMouseMove: handleMouseMove
    }, /*#__PURE__*/ _react.default.createElement("button", {
        className: [
            `${baseClass}__draggable`,
            className
        ].filter(Boolean).join(' '),
        onMouseDown: handleMouseDown,
        onMouseUp: onDrop,
        ref: dragRef,
        style: {
            left: `${position.x}%`,
            top: `${position.y}%`
        },
        type: "button"
    }, children), /*#__PURE__*/ _react.default.createElement("div", null));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL0VkaXRVcGxvYWQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1vZGFsIH0gZnJvbSAnQGZhY2VsZXNzLXVpL21vZGFsJ1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcbmltcG9ydCBSZWFjdENyb3AsIHsgdHlwZSBDcm9wIGFzIENyb3BUeXBlIH0gZnJvbSAncmVhY3QtaW1hZ2UtY3JvcCdcbmltcG9ydCAncmVhY3QtaW1hZ2UtY3JvcC9kaXN0L1JlYWN0Q3JvcC5jc3MnXG5cbmltcG9ydCB0eXBlIHsgRGF0YSB9IGZyb20gJy4uLy4uL2Zvcm1zL0Zvcm0vdHlwZXMnXG5cbmltcG9ydCBQbHVzIGZyb20gJy4uLy4uL2ljb25zL1BsdXMnXG5pbXBvcnQgeyB1c2VVcGxvYWRFZGl0cyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9VcGxvYWRFZGl0cydcbmltcG9ydCB7IGVkaXREcmF3ZXJTbHVnIH0gZnJvbSAnLi4vLi4vdmlld3MvY29sbGVjdGlvbnMvRWRpdC9VcGxvYWQnXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uL0J1dHRvbidcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnZWRpdC11cGxvYWQnXG5cbnR5cGUgUHJvcHMgPSB7XG4gIG5hbWU6IHN0cmluZ1xuICBvbkNoYW5nZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWRcbiAgdmFsdWU6IHN0cmluZ1xufVxuXG5jb25zdCBJbnB1dCA9IGZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUHJvcHM+KChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgbmFtZSwgb25DaGFuZ2UsIHZhbHVlIH0gPSBwcm9wc1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2lucHV0YH0+XG4gICAgICB7bmFtZX1cbiAgICAgIDxpbnB1dFxuICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICBvbkNoYW5nZT17KGUpID0+IG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApXG59KVxuXG50eXBlIEZvY2FsUG9zaXRpb24gPSB7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IEVkaXRVcGxvYWQ6IFJlYWN0LkZDPHtcbiAgZG9jPzogRGF0YVxuICBmaWxlTmFtZTogc3RyaW5nXG4gIGZpbGVTcmM6IHN0cmluZ1xuICBpbWFnZUNhY2hlVGFnPzogc3RyaW5nXG4gIHNob3dDcm9wPzogYm9vbGVhblxuICBzaG93Rm9jYWxQb2ludD86IGJvb2xlYW5cbn0+ID0gKHsgZG9jLCBmaWxlTmFtZSwgZmlsZVNyYywgaW1hZ2VDYWNoZVRhZywgc2hvd0Nyb3AsIHNob3dGb2NhbFBvaW50IH0pID0+IHtcbiAgY29uc3QgeyBjbG9zZU1vZGFsIH0gPSB1c2VNb2RhbCgpXG4gIGNvbnN0IHsgdCB9ID0gdXNlVHJhbnNsYXRpb24oWydnZW5lcmFsJywgJ3VwbG9hZCddKVxuICBjb25zdCB7IHVwZGF0ZVVwbG9hZEVkaXRzLCB1cGxvYWRFZGl0cyB9ID0gdXNlVXBsb2FkRWRpdHMoKVxuXG4gIGNvbnN0IFtmb2NhbFBvc2l0aW9uLCBzZXRGb2NhbFBvc2l0aW9uXSA9IHVzZVN0YXRlPEZvY2FsUG9zaXRpb24+KHtcbiAgICB4OiB1cGxvYWRFZGl0cz8uZm9jYWxQb2ludD8ueCB8fCBkb2MuZm9jYWxYIHx8IDUwLFxuICAgIHk6IHVwbG9hZEVkaXRzPy5mb2NhbFBvaW50Py55IHx8IGRvYy5mb2NhbFkgfHwgNTAsXG4gIH0pXG5cbiAgY29uc3QgW2NoZWNrQm91bmRzLCBzZXRDaGVja0JvdW5kc10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSlcbiAgY29uc3QgW29yaWdpbmFsSGVpZ2h0LCBzZXRPcmlnaW5hbEhlaWdodF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApXG4gIGNvbnN0IFtvcmlnaW5hbFdpZHRoLCBzZXRPcmlnaW5hbFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMClcblxuICBjb25zdCBmb2NhbFdyYXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ+KClcbiAgY29uc3QgaW1hZ2VSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudCB8IHVuZGVmaW5lZD4oKVxuICBjb25zdCBjcm9wUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkPigpXG5cbiAgY29uc3QgaGVpZ2h0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsPihudWxsKVxuICBjb25zdCB3aWR0aFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50IHwgbnVsbD4obnVsbClcblxuICBjb25zdCBbY3JvcCwgc2V0Q3JvcF0gPSB1c2VTdGF0ZTxDcm9wVHlwZT4oe1xuICAgIGhlaWdodDogMTAwLFxuICAgIGhlaWdodFBpeGVsczogMCxcbiAgICB1bml0OiAnJScsXG4gICAgd2lkdGg6IDEwMCxcbiAgICB3aWR0aFBpeGVsczogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gIH0pXG5cbiAgY29uc3QgW2ltYWdlTG9hZGVkLCBzZXRJbWFnZUxvYWRlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSlcblxuICBjb25zdCBvbkltYWdlTG9hZCA9IChlKSA9PiB7XG4gICAgc2V0T3JpZ2luYWxIZWlnaHQoZS5jdXJyZW50VGFyZ2V0Lm5hdHVyYWxIZWlnaHQpXG4gICAgc2V0T3JpZ2luYWxXaWR0aChlLmN1cnJlbnRUYXJnZXQubmF0dXJhbFdpZHRoKVxuICAgIHNldEltYWdlTG9hZGVkKHRydWUpXG4gIH1cblxuICBjb25zdCBmaW5lVHVuZUNyb3AgPSAoeyBkaW1lbnNpb24sIHZhbHVlIH06IHsgZGltZW5zaW9uOiAnaGVpZ2h0JyB8ICd3aWR0aCc7IHZhbHVlOiBzdHJpbmcgfSkgPT4ge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodmFsdWUpXG4gICAgaWYgKGRpbWVuc2lvbiA9PT0gJ3dpZHRoJyAmJiBpbnRWYWx1ZSA+PSBvcmlnaW5hbFdpZHRoKSByZXR1cm4gbnVsbFxuICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnICYmIGludFZhbHVlID49IG9yaWdpbmFsSGVpZ2h0KSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgcGVyY2VudGFnZSA9IDEwMCAqIChpbnRWYWx1ZSAvIChkaW1lbnNpb24gPT09ICd3aWR0aCcgPyBvcmlnaW5hbFdpZHRoIDogb3JpZ2luYWxIZWlnaHQpKVxuXG4gICAgaWYgKHBlcmNlbnRhZ2UgPT09IDEwMCB8fCBwZXJjZW50YWdlID09PSAwKSByZXR1cm4gbnVsbFxuXG4gICAgc2V0Q3JvcCh7XG4gICAgICAuLi5jcm9wLFxuICAgICAgW2RpbWVuc2lvbl06IHBlcmNlbnRhZ2UsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGZpbmVUdW5lRm9jYWxQb3NpdGlvbiA9ICh7XG4gICAgY29vcmRpbmF0ZSxcbiAgICB2YWx1ZSxcbiAgfToge1xuICAgIGNvb3JkaW5hdGU6ICd4JyB8ICd5J1xuICAgIHZhbHVlOiBzdHJpbmdcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodmFsdWUpXG4gICAgaWYgKGludFZhbHVlID49IDAgJiYgaW50VmFsdWUgPD0gMTAwKSB7XG4gICAgICBzZXRGb2NhbFBvc2l0aW9uKChwcmV2UG9zaXRpb24pID0+ICh7IC4uLnByZXZQb3NpdGlvbiwgW2Nvb3JkaW5hdGVdOiBpbnRWYWx1ZSB9KSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBzYXZlRWRpdHMgPSAoKSA9PiB7XG4gICAgdXBkYXRlVXBsb2FkRWRpdHMoe1xuICAgICAgY3JvcDogY3JvcFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmNyb3AsXG4gICAgICAgICAgICBoZWlnaHRQaXhlbHM6IE51bWJlcihoZWlnaHRSZWYuY3VycmVudD8udmFsdWUgPz8gY3JvcC5oZWlnaHRQaXhlbHMpLFxuICAgICAgICAgICAgd2lkdGhQaXhlbHM6IE51bWJlcih3aWR0aFJlZi5jdXJyZW50Py52YWx1ZSA/PyBjcm9wLndpZHRoUGl4ZWxzKSxcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZm9jYWxQb2ludDogZm9jYWxQb3NpdGlvbiA/IGZvY2FsUG9zaXRpb24gOiB1bmRlZmluZWQsXG4gICAgfSlcbiAgICBjbG9zZU1vZGFsKGVkaXREcmF3ZXJTbHVnKVxuICB9XG5cbiAgY29uc3Qgb25EcmFnRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soKHsgeCwgeSB9KSA9PiB7XG4gICAgc2V0Rm9jYWxQb3NpdGlvbih7IHgsIHkgfSlcbiAgICBzZXRDaGVja0JvdW5kcyhmYWxzZSlcbiAgfSwgW10pXG5cbiAgY29uc3QgY2VudGVyRm9jYWxQb2ludCA9ICgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gZm9jYWxXcmFwUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBib3VuZHNSZWN0ID0gc2hvd0Nyb3BcbiAgICAgID8gY3JvcFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICA6IGltYWdlUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB4Q2VudGVyID1cbiAgICAgICgoYm91bmRzUmVjdC5sZWZ0IC0gY29udGFpbmVyUmVjdC5sZWZ0ICsgYm91bmRzUmVjdC53aWR0aCAvIDIpIC8gY29udGFpbmVyUmVjdC53aWR0aCkgKiAxMDBcbiAgICBjb25zdCB5Q2VudGVyID1cbiAgICAgICgoYm91bmRzUmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcCArIGJvdW5kc1JlY3QuaGVpZ2h0IC8gMikgLyBjb250YWluZXJSZWN0LmhlaWdodCkgKiAxMDBcbiAgICBzZXRGb2NhbFBvc2l0aW9uKHsgeDogeENlbnRlciwgeTogeUNlbnRlciB9KVxuICB9XG5cbiAgY29uc3QgZmlsZVNyY1RvVXNlID0gaW1hZ2VDYWNoZVRhZyA/IGAke2ZpbGVTcmN9PyR7aW1hZ2VDYWNoZVRhZ31gIDogZmlsZVNyY1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2Jhc2VDbGFzc30+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9faGVhZGVyYH0+XG4gICAgICAgIDxoMiB0aXRsZT17YCR7dCgnZ2VuZXJhbDplZGl0aW5nJyl9ICR7ZmlsZU5hbWV9YH0+XG4gICAgICAgICAge3QoJ2dlbmVyYWw6ZWRpdGluZycpfSB7ZmlsZU5hbWV9XG4gICAgICAgIDwvaDI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19hY3Rpb25zYH0+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgYXJpYS1sYWJlbD17dCgnY2FuY2VsJyl9XG4gICAgICAgICAgICBidXR0b25TdHlsZT1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2NhbmNlbGB9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBjbG9zZU1vZGFsKGVkaXREcmF3ZXJTbHVnKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dCgnZ2VuZXJhbDpjYW5jZWwnKX1cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXt0KCdnZW5lcmFsOmFwcGx5Q2hhbmdlcycpfVxuICAgICAgICAgICAgYnV0dG9uU3R5bGU9XCJwcmltYXJ5XCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fc2F2ZWB9XG4gICAgICAgICAgICBkaXNhYmxlZD17IWltYWdlTG9hZGVkfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2F2ZUVkaXRzKCl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3QoJ2dlbmVyYWw6YXBwbHlDaGFuZ2VzJyl9XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fdG9vbFdyYXBgfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2Nyb3BgfT5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2ZvY2FsLXdyYXBwZXJgfVxuICAgICAgICAgICAgcmVmPXtmb2NhbFdyYXBSZWZ9XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogYCR7b3JpZ2luYWxXaWR0aCAvIG9yaWdpbmFsSGVpZ2h0fWAsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzaG93Q3JvcCA/IChcbiAgICAgICAgICAgICAgPFJlYWN0Q3JvcFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fcmVhY3RDcm9wYH1cbiAgICAgICAgICAgICAgICBjcm9wPXtjcm9wfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoXywgYykgPT4gc2V0Q3JvcChjKX1cbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlPXsoKSA9PiBzZXRDaGVja0JvdW5kcyh0cnVlKX1cbiAgICAgICAgICAgICAgICByZW5kZXJTZWxlY3Rpb25BZGRvbj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19jcm9wLXdpbmRvd2B9IHJlZj17Y3JvcFJlZn0gLz5cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgYWx0PXt0KCd1cGxvYWQ6c2V0Q3JvcEFyZWEnKX1cbiAgICAgICAgICAgICAgICAgIG9uTG9hZD17b25JbWFnZUxvYWR9XG4gICAgICAgICAgICAgICAgICByZWY9e2ltYWdlUmVmfVxuICAgICAgICAgICAgICAgICAgc3JjPXtmaWxlU3JjVG9Vc2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9SZWFjdENyb3A+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgYWx0PXt0KCd1cGxvYWQ6c2V0Rm9jYWxQb2ludCcpfVxuICAgICAgICAgICAgICAgIG9uTG9hZD17b25JbWFnZUxvYWR9XG4gICAgICAgICAgICAgICAgcmVmPXtpbWFnZVJlZn1cbiAgICAgICAgICAgICAgICBzcmM9e2ZpbGVTcmNUb1VzZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7c2hvd0ZvY2FsUG9pbnQgJiYgKFxuICAgICAgICAgICAgICA8RHJhZ2dhYmxlRWxlbWVudFxuICAgICAgICAgICAgICAgIGJvdW5kc1JlZj17c2hvd0Nyb3AgPyBjcm9wUmVmIDogaW1hZ2VSZWZ9XG4gICAgICAgICAgICAgICAgY2hlY2tCb3VuZHM9e3Nob3dDcm9wID8gY2hlY2tCb3VuZHMgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2ZvY2FsUG9pbnRgfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclJlZj17Zm9jYWxXcmFwUmVmfVxuICAgICAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbj17Zm9jYWxQb3NpdGlvbn1cbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQ9e29uRHJhZ0VuZH1cbiAgICAgICAgICAgICAgICBzZXRDaGVja0JvdW5kcz17c2hvd0Nyb3AgPyBzZXRDaGVja0JvdW5kcyA6IGZhbHNlfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPFBsdXMgLz5cbiAgICAgICAgICAgICAgPC9EcmFnZ2FibGVFbGVtZW50PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHsoc2hvd0Nyb3AgfHwgc2hvd0ZvY2FsUG9pbnQpICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fc2lkZWJhcmB9PlxuICAgICAgICAgICAge3Nob3dDcm9wICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2dyb3VwV3JhcGB9PlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fdGl0bGVXcmFwYH0+XG4gICAgICAgICAgICAgICAgICAgIDxoMz57dCgndXBsb2FkOmNyb3AnKX08L2gzPlxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3R5bGU9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3Jlc2V0YH1cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3JvcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRQaXhlbHM6IG9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0OiAnJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoUGl4ZWxzOiBvcmlnaW5hbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7dCgnZ2VuZXJhbDpyZXNldCcpfVxuICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZGVzY3JpcHRpb25gfT5cbiAgICAgICAgICAgICAgICAgIHt0KCd1cGxvYWQ6Y3JvcFRvb2xEZXNjcmlwdGlvbicpfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9faW5wdXRzV3JhcGB9PlxuICAgICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2Ake3QoJ3VwbG9hZDp3aWR0aCcpfSAocHgpYH1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gZmluZVR1bmVDcm9wKHsgZGltZW5zaW9uOiAnd2lkdGgnLCB2YWx1ZSB9KX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt3aWR0aFJlZn1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9eygoY3JvcC53aWR0aCAvIDEwMCkgKiBvcmlnaW5hbFdpZHRoKS50b0ZpeGVkKDApfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtgJHt0KCd1cGxvYWQ6aGVpZ2h0Jyl9IChweClgfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBmaW5lVHVuZUNyb3AoeyBkaW1lbnNpb246ICdoZWlnaHQnLCB2YWx1ZSB9KX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXtoZWlnaHRSZWZ9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXsoKGNyb3AuaGVpZ2h0IC8gMTAwKSAqIG9yaWdpbmFsSGVpZ2h0KS50b0ZpeGVkKDApfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuXG4gICAgICAgICAgICB7c2hvd0ZvY2FsUG9pbnQgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZ3JvdXBXcmFwYH0+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X190aXRsZVdyYXBgfT5cbiAgICAgICAgICAgICAgICAgICAgPGgzPnt0KCd1cGxvYWQ6Zm9jYWxQb2ludCcpfTwvaDM+XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBidXR0b25TdHlsZT1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fcmVzZXRgfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2NlbnRlckZvY2FsUG9pbnR9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7dCgnZ2VuZXJhbDpyZXNldCcpfVxuICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZGVzY3JpcHRpb25gfT5cbiAgICAgICAgICAgICAgICAgIHt0KCd1cGxvYWQ6Zm9jYWxQb2ludERlc2NyaXB0aW9uJyl9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19pbnB1dHNXcmFwYH0+XG4gICAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cIlggJVwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IGZpbmVUdW5lRm9jYWxQb3NpdGlvbih7IGNvb3JkaW5hdGU6ICd4JywgdmFsdWUgfSl9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmb2NhbFBvc2l0aW9uLngudG9GaXhlZCgwKX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cIlkgJVwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IGZpbmVUdW5lRm9jYWxQb3NpdGlvbih7IGNvb3JkaW5hdGU6ICd5JywgdmFsdWUgfSl9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmb2NhbFBvc2l0aW9uLnkudG9GaXhlZCgwKX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IERyYWdnYWJsZUVsZW1lbnQgPSAoe1xuICBib3VuZHNSZWYsXG4gIGNoZWNrQm91bmRzLFxuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICBjb250YWluZXJSZWYsXG4gIGluaXRpYWxQb3NpdGlvbiA9IHsgeDogNTAsIHk6IDUwIH0sXG4gIG9uRHJhZ0VuZCxcbiAgc2V0Q2hlY2tCb3VuZHMsXG59KSA9PiB7XG4gIGNvbnN0IFtwb3NpdGlvbiwgc2V0UG9zaXRpb25dID0gdXNlU3RhdGUoeyB4OiBpbml0aWFsUG9zaXRpb24ueCwgeTogaW5pdGlhbFBvc2l0aW9uLnkgfSlcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IGRyYWdSZWYgPSB1c2VSZWY8SFRNTEJ1dHRvbkVsZW1lbnQgfCB1bmRlZmluZWQ+KClcblxuICBjb25zdCBnZXRDb29yZGluYXRlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChtb3VzZVhBcmc/OiBudW1iZXIsIG1vdXNlWUFyZz86IG51bWJlciwgcmVjZW50ZXI/OiBib29sZWFuKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXJSZWN0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IGJvdW5kc1JlY3QgPSBib3VuZHNSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgY29uc3QgbW91c2VYID0gbW91c2VYQXJnID8/IGJvdW5kc1JlY3QubGVmdFxuICAgICAgY29uc3QgbW91c2VZID0gbW91c2VZQXJnID8/IGJvdW5kc1JlY3QudG9wXG5cbiAgICAgIGNvbnN0IHhPdXRPZkJvdW5kcyA9IG1vdXNlWCA8IGJvdW5kc1JlY3QubGVmdCB8fCBtb3VzZVggPiBib3VuZHNSZWN0LnJpZ2h0XG4gICAgICBjb25zdCB5T3V0T2ZCb3VuZHMgPSBtb3VzZVkgPCBib3VuZHNSZWN0LnRvcCB8fCBtb3VzZVkgPiBib3VuZHNSZWN0LmJvdHRvbVxuXG4gICAgICBsZXQgeCA9ICgobW91c2VYIC0gY29udGFpbmVyUmVjdC5sZWZ0KSAvIGNvbnRhaW5lclJlY3Qud2lkdGgpICogMTAwXG4gICAgICBsZXQgeSA9ICgobW91c2VZIC0gY29udGFpbmVyUmVjdC50b3ApIC8gY29udGFpbmVyUmVjdC5oZWlnaHQpICogMTAwXG4gICAgICBjb25zdCB4Q2VudGVyID1cbiAgICAgICAgKChib3VuZHNSZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQgKyBib3VuZHNSZWN0LndpZHRoIC8gMikgLyBjb250YWluZXJSZWN0LndpZHRoKSAqIDEwMFxuICAgICAgY29uc3QgeUNlbnRlciA9XG4gICAgICAgICgoYm91bmRzUmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcCArIGJvdW5kc1JlY3QuaGVpZ2h0IC8gMikgLyBjb250YWluZXJSZWN0LmhlaWdodCkgKiAxMDBcbiAgICAgIGlmICh4T3V0T2ZCb3VuZHMgfHwgeU91dE9mQm91bmRzKSB7XG4gICAgICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpXG4gICAgICAgIGlmIChtb3VzZVggPCBib3VuZHNSZWN0LmxlZnQpIHtcbiAgICAgICAgICB4ID0gKChib3VuZHNSZWN0LmxlZnQgLSBjb250YWluZXJSZWN0LmxlZnQpIC8gY29udGFpbmVyUmVjdC53aWR0aCkgKiAxMDBcbiAgICAgICAgfSBlbHNlIGlmIChtb3VzZVggPiBib3VuZHNSZWN0LnJpZ2h0KSB7XG4gICAgICAgICAgeCA9XG4gICAgICAgICAgICAoKGNvbnRhaW5lclJlY3Qud2lkdGggLSAoY29udGFpbmVyUmVjdC5yaWdodCAtIGJvdW5kc1JlY3QucmlnaHQpKSAvXG4gICAgICAgICAgICAgIGNvbnRhaW5lclJlY3Qud2lkdGgpICpcbiAgICAgICAgICAgIDEwMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdXNlWSA8IGJvdW5kc1JlY3QudG9wKSB7XG4gICAgICAgICAgeSA9ICgoYm91bmRzUmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcCkgLyBjb250YWluZXJSZWN0LmhlaWdodCkgKiAxMDBcbiAgICAgICAgfSBlbHNlIGlmIChtb3VzZVkgPiBib3VuZHNSZWN0LmJvdHRvbSkge1xuICAgICAgICAgIHkgPVxuICAgICAgICAgICAgKChjb250YWluZXJSZWN0LmhlaWdodCAtIChjb250YWluZXJSZWN0LmJvdHRvbSAtIGJvdW5kc1JlY3QuYm90dG9tKSkgL1xuICAgICAgICAgICAgICBjb250YWluZXJSZWN0LmhlaWdodCkgKlxuICAgICAgICAgICAgMTAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjZW50ZXIpIHtcbiAgICAgICAgICB4ID0geE91dE9mQm91bmRzID8geENlbnRlciA6IHhcbiAgICAgICAgICB5ID0geU91dE9mQm91bmRzID8geUNlbnRlciA6IHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB4LCB5IH1cbiAgICB9LFxuICAgIFtib3VuZHNSZWYsIGNvbnRhaW5lclJlZl0sXG4gIClcblxuICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgc2V0SXNEcmFnZ2luZyh0cnVlKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcblxuICAgIHNldFBvc2l0aW9uKHsgeCwgeSB9KVxuICB9XG5cbiAgY29uc3Qgb25Ecm9wID0gKCkgPT4ge1xuICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpXG4gICAgb25EcmFnRW5kKHBvc2l0aW9uKVxuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNEcmFnZ2luZyB8fCAhZHJhZ1JlZi5jdXJyZW50KSByZXR1cm5cbiAgICBpZiAoY2hlY2tCb3VuZHMpIHtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0LCBsZWZ0LCB0b3AsIHdpZHRoIH0gPSBkcmFnUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0Q29vcmRpbmF0ZXMobGVmdCArIHdpZHRoIC8gMiwgdG9wICsgaGVpZ2h0IC8gMiwgdHJ1ZSlcbiAgICAgIG9uRHJhZ0VuZCh7IHgsIHkgfSlcbiAgICAgIHNldFBvc2l0aW9uKHsgeCwgeSB9KVxuICAgICAgc2V0Q2hlY2tCb3VuZHMoZmFsc2UpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0sIFtnZXRDb29yZGluYXRlcywgaXNEcmFnZ2luZywgY2hlY2tCb3VuZHMsIHNldENoZWNrQm91bmRzLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBvbkRyYWdFbmRdKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0UG9zaXRpb24oeyB4OiBpbml0aWFsUG9zaXRpb24ueCwgeTogaW5pdGlhbFBvc2l0aW9uLnkgfSlcbiAgfSwgW2luaXRpYWxQb3NpdGlvbi54LCBpbml0aWFsUG9zaXRpb24ueV0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgYCR7YmFzZUNsYXNzfV9fZHJhZ2dhYmxlLWNvbnRhaW5lcmAsXG4gICAgICAgIGlzRHJhZ2dpbmcgJiYgYCR7YmFzZUNsYXNzfV9fZHJhZ2dhYmxlLWNvbnRhaW5lci0tZHJhZ2dpbmdgLFxuICAgICAgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcgJyl9XG4gICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgID5cbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPXtbYCR7YmFzZUNsYXNzfV9fZHJhZ2dhYmxlYCwgY2xhc3NOYW1lXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpfVxuICAgICAgICBvbk1vdXNlRG93bj17aGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlVXA9e29uRHJvcH1cbiAgICAgICAgcmVmPXtkcmFnUmVmfVxuICAgICAgICBzdHlsZT17eyBsZWZ0OiBgJHtwb3NpdGlvbi54fSVgLCB0b3A6IGAke3Bvc2l0aW9uLnl9JWAgfX1cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGRpdiAvPlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsiRWRpdFVwbG9hZCIsImJhc2VDbGFzcyIsIklucHV0IiwiZm9yd2FyZFJlZiIsInByb3BzIiwicmVmIiwibmFtZSIsIm9uQ2hhbmdlIiwidmFsdWUiLCJkaXYiLCJjbGFzc05hbWUiLCJpbnB1dCIsImUiLCJ0YXJnZXQiLCJ0eXBlIiwiZG9jIiwiZmlsZU5hbWUiLCJmaWxlU3JjIiwiaW1hZ2VDYWNoZVRhZyIsInNob3dDcm9wIiwic2hvd0ZvY2FsUG9pbnQiLCJjbG9zZU1vZGFsIiwidXNlTW9kYWwiLCJ0IiwidXNlVHJhbnNsYXRpb24iLCJ1cGRhdGVVcGxvYWRFZGl0cyIsInVwbG9hZEVkaXRzIiwidXNlVXBsb2FkRWRpdHMiLCJmb2NhbFBvc2l0aW9uIiwic2V0Rm9jYWxQb3NpdGlvbiIsInVzZVN0YXRlIiwieCIsImZvY2FsUG9pbnQiLCJmb2NhbFgiLCJ5IiwiZm9jYWxZIiwiY2hlY2tCb3VuZHMiLCJzZXRDaGVja0JvdW5kcyIsIm9yaWdpbmFsSGVpZ2h0Iiwic2V0T3JpZ2luYWxIZWlnaHQiLCJvcmlnaW5hbFdpZHRoIiwic2V0T3JpZ2luYWxXaWR0aCIsImZvY2FsV3JhcFJlZiIsInVzZVJlZiIsImltYWdlUmVmIiwiY3JvcFJlZiIsImhlaWdodFJlZiIsIndpZHRoUmVmIiwiY3JvcCIsInNldENyb3AiLCJoZWlnaHQiLCJoZWlnaHRQaXhlbHMiLCJ1bml0Iiwid2lkdGgiLCJ3aWR0aFBpeGVscyIsImltYWdlTG9hZGVkIiwic2V0SW1hZ2VMb2FkZWQiLCJvbkltYWdlTG9hZCIsImN1cnJlbnRUYXJnZXQiLCJuYXR1cmFsSGVpZ2h0IiwibmF0dXJhbFdpZHRoIiwiZmluZVR1bmVDcm9wIiwiZGltZW5zaW9uIiwiaW50VmFsdWUiLCJwYXJzZUludCIsInBlcmNlbnRhZ2UiLCJmaW5lVHVuZUZvY2FsUG9zaXRpb24iLCJjb29yZGluYXRlIiwicHJldlBvc2l0aW9uIiwic2F2ZUVkaXRzIiwiTnVtYmVyIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImVkaXREcmF3ZXJTbHVnIiwib25EcmFnRW5kIiwiUmVhY3QiLCJ1c2VDYWxsYmFjayIsImNlbnRlckZvY2FsUG9pbnQiLCJjb250YWluZXJSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm91bmRzUmVjdCIsInhDZW50ZXIiLCJsZWZ0IiwieUNlbnRlciIsInRvcCIsImZpbGVTcmNUb1VzZSIsImgyIiwidGl0bGUiLCJCdXR0b24iLCJhcmlhLWxhYmVsIiwiYnV0dG9uU3R5bGUiLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJzdHlsZSIsImFzcGVjdFJhdGlvIiwiUmVhY3RDcm9wIiwiXyIsImMiLCJvbkNvbXBsZXRlIiwicmVuZGVyU2VsZWN0aW9uQWRkb24iLCJpbWciLCJhbHQiLCJvbkxvYWQiLCJzcmMiLCJEcmFnZ2FibGVFbGVtZW50IiwiYm91bmRzUmVmIiwiY29udGFpbmVyUmVmIiwiaW5pdGlhbFBvc2l0aW9uIiwiUGx1cyIsImgzIiwic3BhbiIsInRvRml4ZWQiLCJjaGlsZHJlbiIsInBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJpc0RyYWdnaW5nIiwic2V0SXNEcmFnZ2luZyIsImRyYWdSZWYiLCJnZXRDb29yZGluYXRlcyIsIm1vdXNlWEFyZyIsIm1vdXNlWUFyZyIsInJlY2VudGVyIiwibW91c2VYIiwibW91c2VZIiwieE91dE9mQm91bmRzIiwicmlnaHQiLCJ5T3V0T2ZCb3VuZHMiLCJib3R0b20iLCJoYW5kbGVNb3VzZURvd24iLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlTW91c2VNb3ZlIiwiY2xpZW50WCIsImNsaWVudFkiLCJvbkRyb3AiLCJ1c2VFZmZlY3QiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIm9uTW91c2VNb3ZlIiwiYnV0dG9uIiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7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