"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _reactrouterdom = require("react-router-dom");
const _reacttoastify = require("react-toastify");
const _useDebounce = /*#__PURE__*/ _interop_require_default(require("../../../hooks/useDebounce"));
const _formatDate = require("../../../utilities/formatDate");
const _context = require("../../forms/Form/context");
const _reduceFieldsToValues = /*#__PURE__*/ _interop_require_default(require("../../forms/Form/reduceFieldsToValues"));
const _reduceFieldsToValuesWithValidation = require("../../forms/Form/reduceFieldsToValuesWithValidation");
const _Config = require("../../utilities/Config");
const _DocumentInfo = require("../../utilities/DocumentInfo");
const _Locale = require("../../utilities/Locale");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'autosave';
const Autosave = ({ id, collection, global, publishedDocUpdatedAt })=>{
    const { routes: { admin, api }, serverURL } = (0, _Config.useConfig)();
    const { getVersions, versions } = (0, _DocumentInfo.useDocumentInfo)();
    const [fields] = (0, _context.useAllFormFields)();
    const modified = (0, _context.useFormModified)();
    const { code: locale } = (0, _Locale.useLocale)();
    const submitted = (0, _context.useFormSubmitted)();
    const { dispatchFields, setSubmitted } = (0, _context.useForm)();
    const history = (0, _reactrouterdom.useHistory)();
    const { i18n, t } = (0, _reacti18next.useTranslation)('version');
    let interval = 800;
    const validateDrafts = collection?.versions.drafts && collection.versions?.drafts?.validate || global?.versions.drafts && global.versions?.drafts?.validate;
    if (collection?.versions.drafts && collection.versions?.drafts?.autosave) interval = collection.versions.drafts.autosave.interval;
    if (global?.versions.drafts && global.versions?.drafts?.autosave) interval = global.versions.drafts.autosave.interval;
    const [saving, setSaving] = (0, _react.useState)(false);
    const [lastSaved, setLastSaved] = (0, _react.useState)();
    const debouncedFields = (0, _useDebounce.default)(fields, interval);
    const fieldRef = (0, _react.useRef)(fields);
    const modifiedRef = (0, _react.useRef)(modified);
    const localeRef = (0, _react.useRef)(locale);
    // Store fields in ref so the autosave func
    // can always retrieve the most to date copies
    // after the timeout has executed
    fieldRef.current = fields;
    // Store modified in ref so the autosave func
    // can bail out if modified becomes false while
    // timing out during autosave
    modifiedRef.current = modified;
    const createCollectionDoc = (0, _react.useCallback)(async ()=>{
        const res = await fetch(`${serverURL}${api}/${collection.slug}?locale=${locale}&fallback-locale=null&depth=0&draft=true&autosave=true`, {
            body: JSON.stringify({}),
            credentials: 'include',
            headers: {
                'Accept-Language': i18n.language,
                'Content-Type': 'application/json'
            },
            method: 'POST'
        });
        if (res.status === 201) {
            const json = await res.json();
            history.replace(`${admin}/collections/${collection.slug}/${json.doc.id}`, {
                state: {
                    data: json.doc
                }
            });
        } else {
            _reacttoastify.toast.error(t('error:autosaving'));
        }
    }, [
        serverURL,
        api,
        collection?.slug,
        locale,
        i18n.language,
        history,
        admin,
        t
    ]);
    (0, _react.useEffect)(()=>{
        // If no ID, but this is used for a collection doc,
        // Immediately save it and set lastSaved
        if (!id && collection) {
            void createCollectionDoc();
        }
    }, [
        id,
        collection,
        createCollectionDoc
    ]);
    // When debounced fields change, autosave
    (0, _react.useEffect)(()=>{
        const abortController = new AbortController();
        let autosaveTimeout = undefined;
        const autosave = async ()=>{
            if (modified) {
                setSaving(true);
                let url;
                let method;
                if (collection && id) {
                    url = `${serverURL}${api}/${collection.slug}/${id}?draft=true&autosave=true&locale=${localeRef.current}`;
                    method = 'PATCH';
                }
                if (global) {
                    url = `${serverURL}${api}/globals/${global.slug}?draft=true&autosave=true&locale=${localeRef.current}`;
                    method = 'POST';
                }
                if (url) {
                    autosaveTimeout = setTimeout(async ()=>{
                        if (modifiedRef.current) {
                            const { data, valid } = {
                                ...(0, _reduceFieldsToValuesWithValidation.reduceFieldsToValuesWithValidation)(fieldRef.current, true)
                            };
                            data._status = 'draft';
                            const skipSubmission = submitted && !valid && validateDrafts;
                            if (!skipSubmission) {
                                const res = await fetch(url, {
                                    body: JSON.stringify(data),
                                    credentials: 'include',
                                    headers: {
                                        'Accept-Language': i18n.language,
                                        'Content-Type': 'application/json'
                                    },
                                    method,
                                    signal: abortController.signal
                                });
                                if (res.status === 200) {
                                    const newDate = new Date();
                                    setLastSaved(newDate.getTime());
                                    void getVersions();
                                }
                                if (validateDrafts && res.status === 400) {
                                    const json = await res.json();
                                    if (Array.isArray(json.errors)) {
                                        const [fieldErrors, nonFieldErrors] = json.errors.reduce(([fieldErrs, nonFieldErrs], err)=>{
                                            const newFieldErrs = [];
                                            const newNonFieldErrs = [];
                                            if (err?.message) {
                                                newNonFieldErrs.push(err);
                                            }
                                            if (Array.isArray(err?.data)) {
                                                err.data.forEach((dataError)=>{
                                                    if (dataError?.field) {
                                                        newFieldErrs.push(dataError);
                                                    } else {
                                                        newNonFieldErrs.push(dataError);
                                                    }
                                                });
                                            }
                                            return [
                                                [
                                                    ...fieldErrs,
                                                    ...newFieldErrs
                                                ],
                                                [
                                                    ...nonFieldErrs,
                                                    ...newNonFieldErrs
                                                ]
                                            ];
                                        }, [
                                            [],
                                            []
                                        ]);
                                        fieldErrors.forEach((err)=>{
                                            dispatchFields({
                                                type: 'UPDATE',
                                                errorMessage: err.message,
                                                path: err.field,
                                                valid: false
                                            });
                                        });
                                        nonFieldErrors.forEach((err)=>{
                                            _reacttoastify.toast.error(err.message || i18n.t('error:unknown'));
                                        });
                                        setSubmitted(true);
                                        setSaving(false);
                                        return;
                                    }
                                }
                            }
                            const body = {
                                ...(0, _reduceFieldsToValues.default)(fieldRef.current, true),
                                _status: 'draft'
                            };
                            const res = await fetch(url, {
                                body: JSON.stringify(body),
                                credentials: 'include',
                                headers: {
                                    'Accept-Language': i18n.language,
                                    'Content-Type': 'application/json'
                                },
                                method
                            });
                            if (res.status === 200) {
                                setLastSaved(new Date().getTime());
                                void getVersions();
                            }
                        }
                        setSaving(false);
                    }, 1000);
                }
            }
        };
        void autosave();
        return ()=>{
            clearTimeout(autosaveTimeout);
            if (abortController.signal) abortController.abort();
            setSaving(false);
        };
    }, [
        i18n,
        debouncedFields,
        modified,
        serverURL,
        api,
        collection,
        global,
        id,
        getVersions,
        localeRef,
        modifiedRef,
        submitted,
        validateDrafts,
        setSubmitted,
        dispatchFields
    ]);
    (0, _react.useEffect)(()=>{
        if (versions?.docs?.[0]) {
            setLastSaved(new Date(versions.docs[0].updatedAt).getTime());
        } else if (publishedDocUpdatedAt) {
            setLastSaved(new Date(publishedDocUpdatedAt).getTime());
        }
    }, [
        publishedDocUpdatedAt,
        versions
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: baseClass
    }, saving && t('saving'), !saving && lastSaved && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, t('lastSavedAgo', {
        distance: (0, _formatDate.formatTimeToNow)(lastSaved, i18n.language)
    })));
};
const _default = Autosave;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL0F1dG9zYXZlL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICdyZWFjdC1pMThuZXh0J1xuaW1wb3J0IHsgdXNlSGlzdG9yeSB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5J1xuXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHVzZURlYm91bmNlIGZyb20gJy4uLy4uLy4uL2hvb2tzL3VzZURlYm91bmNlJ1xuaW1wb3J0IHsgZm9ybWF0VGltZVRvTm93IH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL2Zvcm1hdERhdGUnXG5pbXBvcnQge1xuICB1c2VBbGxGb3JtRmllbGRzLFxuICB1c2VGb3JtLFxuICB1c2VGb3JtTW9kaWZpZWQsXG4gIHVzZUZvcm1TdWJtaXR0ZWQsXG59IGZyb20gJy4uLy4uL2Zvcm1zL0Zvcm0vY29udGV4dCdcbmltcG9ydCByZWR1Y2VGaWVsZHNUb1ZhbHVlcyBmcm9tICcuLi8uLi9mb3Jtcy9Gb3JtL3JlZHVjZUZpZWxkc1RvVmFsdWVzJ1xuaW1wb3J0IHsgcmVkdWNlRmllbGRzVG9WYWx1ZXNXaXRoVmFsaWRhdGlvbiB9IGZyb20gJy4uLy4uL2Zvcm1zL0Zvcm0vcmVkdWNlRmllbGRzVG9WYWx1ZXNXaXRoVmFsaWRhdGlvbidcbmltcG9ydCB7IHVzZUNvbmZpZyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9Db25maWcnXG5pbXBvcnQgeyB1c2VEb2N1bWVudEluZm8gfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvRG9jdW1lbnRJbmZvJ1xuaW1wb3J0IHsgdXNlTG9jYWxlIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL0xvY2FsZSdcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuY29uc3QgYmFzZUNsYXNzID0gJ2F1dG9zYXZlJ1xuXG5jb25zdCBBdXRvc2F2ZTogUmVhY3QuRkM8UHJvcHM+ID0gKHsgaWQsIGNvbGxlY3Rpb24sIGdsb2JhbCwgcHVibGlzaGVkRG9jVXBkYXRlZEF0IH0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJvdXRlczogeyBhZG1pbiwgYXBpIH0sXG4gICAgc2VydmVyVVJMLFxuICB9ID0gdXNlQ29uZmlnKClcbiAgY29uc3QgeyBnZXRWZXJzaW9ucywgdmVyc2lvbnMgfSA9IHVzZURvY3VtZW50SW5mbygpXG4gIGNvbnN0IFtmaWVsZHNdID0gdXNlQWxsRm9ybUZpZWxkcygpXG4gIGNvbnN0IG1vZGlmaWVkID0gdXNlRm9ybU1vZGlmaWVkKClcbiAgY29uc3QgeyBjb2RlOiBsb2NhbGUgfSA9IHVzZUxvY2FsZSgpXG4gIGNvbnN0IHN1Ym1pdHRlZCA9IHVzZUZvcm1TdWJtaXR0ZWQoKVxuICBjb25zdCB7IGRpc3BhdGNoRmllbGRzLCBzZXRTdWJtaXR0ZWQgfSA9IHVzZUZvcm0oKVxuICBjb25zdCBoaXN0b3J5ID0gdXNlSGlzdG9yeSgpXG4gIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlVHJhbnNsYXRpb24oJ3ZlcnNpb24nKVxuXG4gIGxldCBpbnRlcnZhbCA9IDgwMFxuICBjb25zdCB2YWxpZGF0ZURyYWZ0cyA9XG4gICAgKGNvbGxlY3Rpb24/LnZlcnNpb25zLmRyYWZ0cyAmJiBjb2xsZWN0aW9uLnZlcnNpb25zPy5kcmFmdHM/LnZhbGlkYXRlKSB8fFxuICAgIChnbG9iYWw/LnZlcnNpb25zLmRyYWZ0cyAmJiBnbG9iYWwudmVyc2lvbnM/LmRyYWZ0cz8udmFsaWRhdGUpXG4gIGlmIChjb2xsZWN0aW9uPy52ZXJzaW9ucy5kcmFmdHMgJiYgY29sbGVjdGlvbi52ZXJzaW9ucz8uZHJhZnRzPy5hdXRvc2F2ZSlcbiAgICBpbnRlcnZhbCA9IGNvbGxlY3Rpb24udmVyc2lvbnMuZHJhZnRzLmF1dG9zYXZlLmludGVydmFsXG4gIGlmIChnbG9iYWw/LnZlcnNpb25zLmRyYWZ0cyAmJiBnbG9iYWwudmVyc2lvbnM/LmRyYWZ0cz8uYXV0b3NhdmUpXG4gICAgaW50ZXJ2YWwgPSBnbG9iYWwudmVyc2lvbnMuZHJhZnRzLmF1dG9zYXZlLmludGVydmFsXG5cbiAgY29uc3QgW3NhdmluZywgc2V0U2F2aW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbbGFzdFNhdmVkLCBzZXRMYXN0U2F2ZWRdID0gdXNlU3RhdGU8bnVtYmVyPigpXG4gIGNvbnN0IGRlYm91bmNlZEZpZWxkcyA9IHVzZURlYm91bmNlKGZpZWxkcywgaW50ZXJ2YWwpXG4gIGNvbnN0IGZpZWxkUmVmID0gdXNlUmVmKGZpZWxkcylcbiAgY29uc3QgbW9kaWZpZWRSZWYgPSB1c2VSZWYobW9kaWZpZWQpXG4gIGNvbnN0IGxvY2FsZVJlZiA9IHVzZVJlZihsb2NhbGUpXG5cbiAgLy8gU3RvcmUgZmllbGRzIGluIHJlZiBzbyB0aGUgYXV0b3NhdmUgZnVuY1xuICAvLyBjYW4gYWx3YXlzIHJldHJpZXZlIHRoZSBtb3N0IHRvIGRhdGUgY29waWVzXG4gIC8vIGFmdGVyIHRoZSB0aW1lb3V0IGhhcyBleGVjdXRlZFxuICBmaWVsZFJlZi5jdXJyZW50ID0gZmllbGRzXG5cbiAgLy8gU3RvcmUgbW9kaWZpZWQgaW4gcmVmIHNvIHRoZSBhdXRvc2F2ZSBmdW5jXG4gIC8vIGNhbiBiYWlsIG91dCBpZiBtb2RpZmllZCBiZWNvbWVzIGZhbHNlIHdoaWxlXG4gIC8vIHRpbWluZyBvdXQgZHVyaW5nIGF1dG9zYXZlXG4gIG1vZGlmaWVkUmVmLmN1cnJlbnQgPSBtb2RpZmllZFxuXG4gIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb25Eb2MgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtzZXJ2ZXJVUkx9JHthcGl9LyR7Y29sbGVjdGlvbi5zbHVnfT9sb2NhbGU9JHtsb2NhbGV9JmZhbGxiYWNrLWxvY2FsZT1udWxsJmRlcHRoPTAmZHJhZnQ9dHJ1ZSZhdXRvc2F2ZT10cnVlYCxcbiAgICAgIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe30pLFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGkxOG4ubGFuZ3VhZ2UsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB9LFxuICAgIClcblxuICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDEpIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpXG4gICAgICBoaXN0b3J5LnJlcGxhY2UoYCR7YWRtaW59L2NvbGxlY3Rpb25zLyR7Y29sbGVjdGlvbi5zbHVnfS8ke2pzb24uZG9jLmlkfWAsIHtcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBkYXRhOiBqc29uLmRvYyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRvYXN0LmVycm9yKHQoJ2Vycm9yOmF1dG9zYXZpbmcnKSlcbiAgICB9XG4gIH0sIFtzZXJ2ZXJVUkwsIGFwaSwgY29sbGVjdGlvbj8uc2x1ZywgbG9jYWxlLCBpMThuLmxhbmd1YWdlLCBoaXN0b3J5LCBhZG1pbiwgdF0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiBubyBJRCwgYnV0IHRoaXMgaXMgdXNlZCBmb3IgYSBjb2xsZWN0aW9uIGRvYyxcbiAgICAvLyBJbW1lZGlhdGVseSBzYXZlIGl0IGFuZCBzZXQgbGFzdFNhdmVkXG4gICAgaWYgKCFpZCAmJiBjb2xsZWN0aW9uKSB7XG4gICAgICB2b2lkIGNyZWF0ZUNvbGxlY3Rpb25Eb2MoKVxuICAgIH1cbiAgfSwgW2lkLCBjb2xsZWN0aW9uLCBjcmVhdGVDb2xsZWN0aW9uRG9jXSlcblxuICAvLyBXaGVuIGRlYm91bmNlZCBmaWVsZHMgY2hhbmdlLCBhdXRvc2F2ZVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgbGV0IGF1dG9zYXZlVGltZW91dCA9IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgYXV0b3NhdmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgc2V0U2F2aW5nKHRydWUpXG5cbiAgICAgICAgbGV0IHVybDogc3RyaW5nXG4gICAgICAgIGxldCBtZXRob2Q6IHN0cmluZ1xuXG4gICAgICAgIGlmIChjb2xsZWN0aW9uICYmIGlkKSB7XG4gICAgICAgICAgdXJsID0gYCR7c2VydmVyVVJMfSR7YXBpfS8ke2NvbGxlY3Rpb24uc2x1Z30vJHtpZH0/ZHJhZnQ9dHJ1ZSZhdXRvc2F2ZT10cnVlJmxvY2FsZT0ke2xvY2FsZVJlZi5jdXJyZW50fWBcbiAgICAgICAgICBtZXRob2QgPSAnUEFUQ0gnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgdXJsID0gYCR7c2VydmVyVVJMfSR7YXBpfS9nbG9iYWxzLyR7Z2xvYmFsLnNsdWd9P2RyYWZ0PXRydWUmYXV0b3NhdmU9dHJ1ZSZsb2NhbGU9JHtsb2NhbGVSZWYuY3VycmVudH1gXG4gICAgICAgICAgbWV0aG9kID0gJ1BPU1QnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgYXV0b3NhdmVUaW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIHZhbGlkIH0gPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVkdWNlRmllbGRzVG9WYWx1ZXNXaXRoVmFsaWRhdGlvbihmaWVsZFJlZi5jdXJyZW50LCB0cnVlKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhLl9zdGF0dXMgPSAnZHJhZnQnXG4gICAgICAgICAgICAgIGNvbnN0IHNraXBTdWJtaXNzaW9uID0gc3VibWl0dGVkICYmICF2YWxpZCAmJiB2YWxpZGF0ZURyYWZ0c1xuXG4gICAgICAgICAgICAgIGlmICghc2tpcFN1Ym1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGkxOG4ubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgc2V0TGFzdFNhdmVkKG5ld0RhdGUuZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgdm9pZCBnZXRWZXJzaW9ucygpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRHJhZnRzICYmIHJlcy5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKClcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24uZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmllbGRFcnJvcnMsIG5vbkZpZWxkRXJyb3JzXSA9IGpzb24uZXJyb3JzLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgICAoW2ZpZWxkRXJycywgbm9uRmllbGRFcnJzXSwgZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWVsZEVycnMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9uRmllbGRFcnJzID0gW11cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycj8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb25GaWVsZEVycnMucHVzaChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycj8uZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmRhdGEuZm9yRWFjaCgoZGF0YUVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFFcnJvcj8uZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkRXJycy5wdXNoKGRhdGFFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9uRmllbGRFcnJzLnB1c2goZGF0YUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWy4uLmZpZWxkRXJycywgLi4ubmV3RmllbGRFcnJzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWy4uLm5vbkZpZWxkRXJycywgLi4ubmV3Tm9uRmllbGRFcnJzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtbXSwgW11dLFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hGaWVsZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1VQREFURScsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZXJyLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgbm9uRmllbGRFcnJvcnMuZm9yRWFjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9hc3QuZXJyb3IoZXJyLm1lc3NhZ2UgfHwgaTE4bi50KCdlcnJvcjp1bmtub3duJykpXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0U3VibWl0dGVkKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHNldFNhdmluZyhmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi5yZWR1Y2VGaWVsZHNUb1ZhbHVlcyhmaWVsZFJlZi5jdXJyZW50LCB0cnVlKSxcbiAgICAgICAgICAgICAgICBfc3RhdHVzOiAnZHJhZnQnLFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHNldExhc3RTYXZlZChuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICB2b2lkIGdldFZlcnNpb25zKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRTYXZpbmcoZmFsc2UpXG4gICAgICAgICAgfSwgMTAwMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZvaWQgYXV0b3NhdmUoKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChhdXRvc2F2ZVRpbWVvdXQpXG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbCkgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIHNldFNhdmluZyhmYWxzZSlcbiAgICB9XG4gIH0sIFtcbiAgICBpMThuLFxuICAgIGRlYm91bmNlZEZpZWxkcyxcbiAgICBtb2RpZmllZCxcbiAgICBzZXJ2ZXJVUkwsXG4gICAgYXBpLFxuICAgIGNvbGxlY3Rpb24sXG4gICAgZ2xvYmFsLFxuICAgIGlkLFxuICAgIGdldFZlcnNpb25zLFxuICAgIGxvY2FsZVJlZixcbiAgICBtb2RpZmllZFJlZixcbiAgICBzdWJtaXR0ZWQsXG4gICAgdmFsaWRhdGVEcmFmdHMsXG4gICAgc2V0U3VibWl0dGVkLFxuICAgIGRpc3BhdGNoRmllbGRzLFxuICBdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZlcnNpb25zPy5kb2NzPy5bMF0pIHtcbiAgICAgIHNldExhc3RTYXZlZChuZXcgRGF0ZSh2ZXJzaW9ucy5kb2NzWzBdLnVwZGF0ZWRBdCkuZ2V0VGltZSgpKVxuICAgIH0gZWxzZSBpZiAocHVibGlzaGVkRG9jVXBkYXRlZEF0KSB7XG4gICAgICBzZXRMYXN0U2F2ZWQobmV3IERhdGUocHVibGlzaGVkRG9jVXBkYXRlZEF0KS5nZXRUaW1lKCkpXG4gICAgfVxuICB9LCBbcHVibGlzaGVkRG9jVXBkYXRlZEF0LCB2ZXJzaW9uc10pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YmFzZUNsYXNzfT5cbiAgICAgIHtzYXZpbmcgJiYgdCgnc2F2aW5nJyl9XG4gICAgICB7IXNhdmluZyAmJiBsYXN0U2F2ZWQgJiYgKFxuICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAge3QoJ2xhc3RTYXZlZEFnbycsIHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBmb3JtYXRUaW1lVG9Ob3cobGFzdFNhdmVkLCBpMThuLmxhbmd1YWdlKSxcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0b3NhdmVcbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJBdXRvc2F2ZSIsImlkIiwiY29sbGVjdGlvbiIsImdsb2JhbCIsInB1Ymxpc2hlZERvY1VwZGF0ZWRBdCIsInJvdXRlcyIsImFkbWluIiwiYXBpIiwic2VydmVyVVJMIiwidXNlQ29uZmlnIiwiZ2V0VmVyc2lvbnMiLCJ2ZXJzaW9ucyIsInVzZURvY3VtZW50SW5mbyIsImZpZWxkcyIsInVzZUFsbEZvcm1GaWVsZHMiLCJtb2RpZmllZCIsInVzZUZvcm1Nb2RpZmllZCIsImNvZGUiLCJsb2NhbGUiLCJ1c2VMb2NhbGUiLCJzdWJtaXR0ZWQiLCJ1c2VGb3JtU3VibWl0dGVkIiwiZGlzcGF0Y2hGaWVsZHMiLCJzZXRTdWJtaXR0ZWQiLCJ1c2VGb3JtIiwiaGlzdG9yeSIsInVzZUhpc3RvcnkiLCJpMThuIiwidCIsInVzZVRyYW5zbGF0aW9uIiwiaW50ZXJ2YWwiLCJ2YWxpZGF0ZURyYWZ0cyIsImRyYWZ0cyIsInZhbGlkYXRlIiwiYXV0b3NhdmUiLCJzYXZpbmciLCJzZXRTYXZpbmciLCJ1c2VTdGF0ZSIsImxhc3RTYXZlZCIsInNldExhc3RTYXZlZCIsImRlYm91bmNlZEZpZWxkcyIsInVzZURlYm91bmNlIiwiZmllbGRSZWYiLCJ1c2VSZWYiLCJtb2RpZmllZFJlZiIsImxvY2FsZVJlZiIsImN1cnJlbnQiLCJjcmVhdGVDb2xsZWN0aW9uRG9jIiwidXNlQ2FsbGJhY2siLCJyZXMiLCJmZXRjaCIsInNsdWciLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImxhbmd1YWdlIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsInJlcGxhY2UiLCJkb2MiLCJzdGF0ZSIsImRhdGEiLCJ0b2FzdCIsImVycm9yIiwidXNlRWZmZWN0IiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYXV0b3NhdmVUaW1lb3V0IiwidW5kZWZpbmVkIiwidXJsIiwic2V0VGltZW91dCIsInZhbGlkIiwicmVkdWNlRmllbGRzVG9WYWx1ZXNXaXRoVmFsaWRhdGlvbiIsIl9zdGF0dXMiLCJza2lwU3VibWlzc2lvbiIsInNpZ25hbCIsIm5ld0RhdGUiLCJEYXRlIiwiZ2V0VGltZSIsIkFycmF5IiwiaXNBcnJheSIsImVycm9ycyIsImZpZWxkRXJyb3JzIiwibm9uRmllbGRFcnJvcnMiLCJyZWR1Y2UiLCJmaWVsZEVycnMiLCJub25GaWVsZEVycnMiLCJlcnIiLCJuZXdGaWVsZEVycnMiLCJuZXdOb25GaWVsZEVycnMiLCJtZXNzYWdlIiwicHVzaCIsImZvckVhY2giLCJkYXRhRXJyb3IiLCJmaWVsZCIsInR5cGUiLCJlcnJvck1lc3NhZ2UiLCJwYXRoIiwicmVkdWNlRmllbGRzVG9WYWx1ZXMiLCJjbGVhclRpbWVvdXQiLCJhYm9ydCIsImRvY3MiLCJ1cGRhdGVkQXQiLCJkaXYiLCJjbGFzc05hbWUiLCJSZWFjdCIsIkZyYWdtZW50IiwiZGlzdGFuY2UiLCJmb3JtYXRUaW1lVG9Ob3ciXSwicmFuZ2VNYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7OytCQStRQTs7O2VBQUE7OzsrREEvUWdFOzhCQUNqQztnQ0FDSjsrQkFDTDtvRUFJRTs0QkFDUTt5QkFNekI7NkVBQzBCO29EQUNrQjt3QkFDekI7OEJBQ007d0JBQ047UUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1AsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyxXQUE0QixDQUFDLEVBQUVDLEVBQUUsRUFBRUMs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