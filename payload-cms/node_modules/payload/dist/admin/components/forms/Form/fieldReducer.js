"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "fieldReducer", {
    enumerable: true,
    get: function() {
        return fieldReducer;
    }
});
const _bsonobjectid = /*#__PURE__*/ _interop_require_default(require("bson-objectid"));
const _deepequal = /*#__PURE__*/ _interop_require_default(require("deep-equal"));
const _deepCopyObject = require("../../../../utilities/deepCopyObject");
const _getSiblingData = /*#__PURE__*/ _interop_require_default(require("./getSiblingData"));
const _reduceFieldsToValues = /*#__PURE__*/ _interop_require_default(require("./reduceFieldsToValues"));
const _rows = require("./rows");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function fieldReducer(state, action) {
    switch(action.type){
        case 'REPLACE_STATE':
            {
                const newState = {};
                // Only update fields that have changed
                // by comparing old value / initialValue to new
                // ..
                // This is a performance enhancement for saving
                // large documents with hundreds of fields
                Object.entries(action.state).forEach(([path, field])=>{
                    const oldField = state[path];
                    const newField = field;
                    if (!(0, _deepequal.default)(oldField, newField)) {
                        newState[path] = newField;
                    } else if (oldField) {
                        newState[path] = oldField;
                    }
                });
                return newState;
            }
        case 'REMOVE':
            {
                const newState = {
                    ...state
                };
                if (newState[action.path]) delete newState[action.path];
                return newState;
            }
        case 'MODIFY_CONDITION':
            {
                const { path, result, user } = action;
                return Object.entries(state).reduce((newState, [fieldPath, field])=>{
                    if (fieldPath === path || fieldPath.indexOf(`${path}.`) === 0) {
                        let passesCondition = result;
                        // If a condition is being set to true,
                        // Set all conditions to true
                        // Besides those who still fail their own conditions
                        if (passesCondition && field.condition) {
                            passesCondition = Boolean(field.condition((0, _reduceFieldsToValues.default)(state, true), (0, _getSiblingData.default)(state, path), {
                                user
                            }));
                        }
                        return {
                            ...newState,
                            [fieldPath]: {
                                ...field,
                                passesCondition
                            }
                        };
                    }
                    return {
                        ...newState,
                        [fieldPath]: {
                            ...field
                        }
                    };
                }, {});
            }
        case 'UPDATE':
            {
                const newField = Object.entries(action).reduce((field, [key, value])=>{
                    if ([
                        'condition',
                        'disableFormData',
                        'errorMessage',
                        'initialValue',
                        'passesCondition',
                        'previousValue',
                        'rows',
                        'valid',
                        'validate',
                        'value'
                    ].includes(key)) {
                        return {
                            ...field,
                            [key]: value
                        };
                    }
                    return field;
                }, state[action.path] || {});
                return {
                    ...state,
                    [action.path]: newField
                };
            }
        case 'REMOVE_ROW':
            {
                const { path, rowIndex } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rows.splice(rowIndex, 1);
                rowsMetadata.splice(rowIndex, 1);
                const newState = {
                    ...remainingFields,
                    [path]: {
                        ...state[path],
                        disableFormData: rows.length > 0,
                        rows: rowsMetadata,
                        value: rows.length
                    },
                    ...(0, _rows.flattenRows)(path, rows)
                };
                return newState;
            }
        case 'ADD_ROW':
            {
                const { blockType, path, rowIndex: rowIndexFromArgs, subFieldState } = action;
                const rowIndex = typeof rowIndexFromArgs === 'number' ? rowIndexFromArgs : state[path]?.rows?.length || 0;
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rowsMetadata.splice(rowIndex, 0, // new row
                {
                    id: new _bsonobjectid.default().toHexString(),
                    blockType: blockType || undefined,
                    childErrorPaths: new Set(),
                    collapsed: false
                });
                if (blockType) {
                    subFieldState.blockType = {
                        initialValue: blockType,
                        valid: true,
                        value: blockType
                    };
                }
                // add new row to array _field state_
                const { remainingFields, rows: siblingRows } = (0, _rows.separateRows)(path, state);
                siblingRows.splice(rowIndex, 0, subFieldState);
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, siblingRows),
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: siblingRows.length
                    }
                };
                return newState;
            }
        case 'REPLACE_ROW':
            {
                const { blockType, path, rowIndex: rowIndexArg, subFieldState } = action;
                const { remainingFields, rows: siblingRows } = (0, _rows.separateRows)(path, state);
                const rowIndex = Math.max(0, Math.min(rowIndexArg, siblingRows?.length - 1 || 0));
                const rowsMetadata = [
                    ...state[path]?.rows || []
                ];
                rowsMetadata[rowIndex] = {
                    id: new _bsonobjectid.default().toHexString(),
                    blockType: blockType || undefined,
                    childErrorPaths: new Set(),
                    collapsed: false
                };
                if (blockType) {
                    subFieldState.blockType = {
                        initialValue: blockType,
                        valid: true,
                        value: blockType
                    };
                }
                // replace form _field state_
                siblingRows[rowIndex] = subFieldState;
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, siblingRows),
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: siblingRows.length
                    }
                };
                return newState;
            }
        case 'DUPLICATE_ROW':
            {
                const { path, rowIndex } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                const rowsMetadata = state[path]?.rows || [];
                const duplicateRowMetadata = (0, _deepCopyObject.deepCopyObject)(rowsMetadata[rowIndex]);
                if (duplicateRowMetadata.id) duplicateRowMetadata.id = new _bsonobjectid.default().toHexString();
                const duplicateRowState = (0, _deepCopyObject.deepCopyObject)(rows[rowIndex]);
                if (duplicateRowState.id) duplicateRowState.id = new _bsonobjectid.default().toHexString();
                // If there are subfields
                if (Object.keys(duplicateRowState).length > 0) {
                    // Add new object containing subfield names to unflattenedRows array
                    rows.splice(rowIndex + 1, 0, duplicateRowState);
                    rowsMetadata.splice(rowIndex + 1, 0, duplicateRowMetadata);
                }
                const newState = {
                    ...remainingFields,
                    [path]: {
                        ...state[path],
                        disableFormData: true,
                        rows: rowsMetadata,
                        value: rows.length
                    },
                    ...(0, _rows.flattenRows)(path, rows)
                };
                return newState;
            }
        case 'MOVE_ROW':
            {
                const { moveFromIndex, moveToIndex, path } = action;
                const { remainingFields, rows } = (0, _rows.separateRows)(path, state);
                // copy the row to move
                const copyOfMovingRow = rows[moveFromIndex];
                // delete the row by index
                rows.splice(moveFromIndex, 1);
                // insert row copyOfMovingRow back in
                rows.splice(moveToIndex, 0, copyOfMovingRow);
                // modify array/block internal row state (i.e. collapsed, blockType)
                const rowStateCopy = [
                    ...state[path]?.rows || []
                ];
                const movingRowState = {
                    ...rowStateCopy[moveFromIndex]
                };
                rowStateCopy.splice(moveFromIndex, 1);
                rowStateCopy.splice(moveToIndex, 0, movingRowState);
                const newState = {
                    ...remainingFields,
                    ...(0, _rows.flattenRows)(path, rows),
                    [path]: {
                        ...state[path],
                        rows: rowStateCopy
                    }
                };
                return newState;
            }
        case 'SET_ROW_COLLAPSED':
            {
                const { collapsed, path, rowID, setDocFieldPreferences } = action;
                const arrayState = state[path];
                const { collapsedRowIDs, matchedIndex } = state[path].rows.reduce((acc, row, index)=>{
                    const isMatchingRow = row.id === rowID;
                    if (isMatchingRow) acc.matchedIndex = index;
                    if (!isMatchingRow && row.collapsed) acc.collapsedRowIDs.push(row.id);
                    else if (isMatchingRow && collapsed) acc.collapsedRowIDs.push(row.id);
                    return acc;
                }, {
                    collapsedRowIDs: [],
                    matchedIndex: undefined
                });
                if (matchedIndex > -1) {
                    arrayState.rows[matchedIndex].collapsed = collapsed;
                    setDocFieldPreferences(path, {
                        collapsed: collapsedRowIDs
                    });
                }
                const newState = {
                    ...state,
                    [path]: {
                        ...arrayState
                    }
                };
                return newState;
            }
        case 'SET_ALL_ROWS_COLLAPSED':
            {
                const { collapsed, path, setDocFieldPreferences } = action;
                const { collapsedRowIDs, rows } = state[path].rows.reduce((acc, row)=>{
                    if (collapsed) acc.collapsedRowIDs.push(row.id);
                    acc.rows.push({
                        ...row,
                        collapsed
                    });
                    return acc;
                }, {
                    collapsedRowIDs: [],
                    rows: []
                });
                setDocFieldPreferences(path, {
                    collapsed: collapsedRowIDs
                });
                return {
                    ...state,
                    [path]: {
                        ...state[path],
                        rows
                    }
                };
            }
        default:
            {
                return state;
            }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL0Zvcm0vZmllbGRSZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPYmplY3RJRCBmcm9tICdic29uLW9iamVjdGlkJ1xuaW1wb3J0IGVxdWFsIGZyb20gJ2RlZXAtZXF1YWwnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRBY3Rpb24sIEZpZWxkcywgRm9ybUZpZWxkIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgZGVlcENvcHlPYmplY3QgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvZGVlcENvcHlPYmplY3QnXG5pbXBvcnQgZ2V0U2libGluZ0RhdGEgZnJvbSAnLi9nZXRTaWJsaW5nRGF0YSdcbmltcG9ydCByZWR1Y2VGaWVsZHNUb1ZhbHVlcyBmcm9tICcuL3JlZHVjZUZpZWxkc1RvVmFsdWVzJ1xuaW1wb3J0IHsgZmxhdHRlblJvd3MsIHNlcGFyYXRlUm93cyB9IGZyb20gJy4vcm93cydcblxuLyoqXG4gKiBSZWR1Y2VyIHdoaWNoIG1vZGlmaWVzIHRoZSBmb3JtIGZpZWxkIHN0YXRlIChhbGwgdGhlIGN1cnJlbnQgZGF0YSBvZiB0aGUgZmllbGRzIGluIHRoZSBmb3JtKS4gV2hlbiBjYWxsZWQgdXNpbmcgZGlzcGF0Y2gsIGl0IHdpbGwgcmV0dXJuIGEgbmV3IHN0YXRlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkUmVkdWNlcihzdGF0ZTogRmllbGRzLCBhY3Rpb246IEZpZWxkQWN0aW9uKTogRmllbGRzIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1JFUExBQ0VfU1RBVEUnOiB7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHt9XG5cbiAgICAgIC8vIE9ubHkgdXBkYXRlIGZpZWxkcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gYnkgY29tcGFyaW5nIG9sZCB2YWx1ZSAvIGluaXRpYWxWYWx1ZSB0byBuZXdcbiAgICAgIC8vIC4uXG4gICAgICAvLyBUaGlzIGlzIGEgcGVyZm9ybWFuY2UgZW5oYW5jZW1lbnQgZm9yIHNhdmluZ1xuICAgICAgLy8gbGFyZ2UgZG9jdW1lbnRzIHdpdGggaHVuZHJlZHMgb2YgZmllbGRzXG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKGFjdGlvbi5zdGF0ZSkuZm9yRWFjaCgoW3BhdGgsIGZpZWxkXSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRGaWVsZCA9IHN0YXRlW3BhdGhdXG4gICAgICAgIGNvbnN0IG5ld0ZpZWxkID0gZmllbGRcblxuICAgICAgICBpZiAoIWVxdWFsKG9sZEZpZWxkLCBuZXdGaWVsZCkpIHtcbiAgICAgICAgICBuZXdTdGF0ZVtwYXRoXSA9IG5ld0ZpZWxkXG4gICAgICAgIH0gZWxzZSBpZiAob2xkRmllbGQpIHtcbiAgICAgICAgICBuZXdTdGF0ZVtwYXRoXSA9IG9sZEZpZWxkXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH1cblxuICAgIGNhc2UgJ1JFTU9WRSc6IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5zdGF0ZSB9XG4gICAgICBpZiAobmV3U3RhdGVbYWN0aW9uLnBhdGhdKSBkZWxldGUgbmV3U3RhdGVbYWN0aW9uLnBhdGhdXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdNT0RJRllfQ09ORElUSU9OJzoge1xuICAgICAgY29uc3QgeyBwYXRoLCByZXN1bHQsIHVzZXIgfSA9IGFjdGlvblxuXG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIFtmaWVsZFBhdGgsIGZpZWxkXSkgPT4ge1xuICAgICAgICBpZiAoZmllbGRQYXRoID09PSBwYXRoIHx8IGZpZWxkUGF0aC5pbmRleE9mKGAke3BhdGh9LmApID09PSAwKSB7XG4gICAgICAgICAgbGV0IHBhc3Nlc0NvbmRpdGlvbiA9IHJlc3VsdFxuXG4gICAgICAgICAgLy8gSWYgYSBjb25kaXRpb24gaXMgYmVpbmcgc2V0IHRvIHRydWUsXG4gICAgICAgICAgLy8gU2V0IGFsbCBjb25kaXRpb25zIHRvIHRydWVcbiAgICAgICAgICAvLyBCZXNpZGVzIHRob3NlIHdobyBzdGlsbCBmYWlsIHRoZWlyIG93biBjb25kaXRpb25zXG5cbiAgICAgICAgICBpZiAocGFzc2VzQ29uZGl0aW9uICYmIGZpZWxkLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgcGFzc2VzQ29uZGl0aW9uID0gQm9vbGVhbihcbiAgICAgICAgICAgICAgZmllbGQuY29uZGl0aW9uKHJlZHVjZUZpZWxkc1RvVmFsdWVzKHN0YXRlLCB0cnVlKSwgZ2V0U2libGluZ0RhdGEoc3RhdGUsIHBhdGgpLCB7XG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgIHBhc3Nlc0NvbmRpdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG4gICAgfVxuXG4gICAgY2FzZSAnVVBEQVRFJzoge1xuICAgICAgY29uc3QgbmV3RmllbGQgPSBPYmplY3QuZW50cmllcyhhY3Rpb24pLnJlZHVjZShcbiAgICAgICAgKGZpZWxkLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdjb25kaXRpb24nLFxuICAgICAgICAgICAgICAnZGlzYWJsZUZvcm1EYXRhJyxcbiAgICAgICAgICAgICAgJ2Vycm9yTWVzc2FnZScsXG4gICAgICAgICAgICAgICdpbml0aWFsVmFsdWUnLFxuICAgICAgICAgICAgICAncGFzc2VzQ29uZGl0aW9uJyxcbiAgICAgICAgICAgICAgJ3ByZXZpb3VzVmFsdWUnLFxuICAgICAgICAgICAgICAncm93cycsXG4gICAgICAgICAgICAgICd2YWxpZCcsXG4gICAgICAgICAgICAgICd2YWxpZGF0ZScsXG4gICAgICAgICAgICAgICd2YWx1ZScsXG4gICAgICAgICAgICBdLmluY2x1ZGVzKGtleSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgICBba2V5XTogdmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZpZWxkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlW2FjdGlvbi5wYXRoXSB8fCAoe30gYXMgRm9ybUZpZWxkKSxcbiAgICAgIClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFthY3Rpb24ucGF0aF06IG5ld0ZpZWxkLFxuICAgICAgfVxuICAgIH1cblxuICAgIGNhc2UgJ1JFTU9WRV9ST1cnOiB7XG4gICAgICBjb25zdCB7IHBhdGgsIHJvd0luZGV4IH0gPSBhY3Rpb25cbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nRmllbGRzLCByb3dzIH0gPSBzZXBhcmF0ZVJvd3MocGF0aCwgc3RhdGUpXG4gICAgICBjb25zdCByb3dzTWV0YWRhdGEgPSBbLi4uKHN0YXRlW3BhdGhdPy5yb3dzIHx8IFtdKV1cblxuICAgICAgcm93cy5zcGxpY2Uocm93SW5kZXgsIDEpXG4gICAgICByb3dzTWV0YWRhdGEuc3BsaWNlKHJvd0luZGV4LCAxKVxuXG4gICAgICBjb25zdCBuZXdTdGF0ZTogRmllbGRzID0ge1xuICAgICAgICAuLi5yZW1haW5pbmdGaWVsZHMsXG4gICAgICAgIFtwYXRoXToge1xuICAgICAgICAgIC4uLnN0YXRlW3BhdGhdLFxuICAgICAgICAgIGRpc2FibGVGb3JtRGF0YTogcm93cy5sZW5ndGggPiAwLFxuICAgICAgICAgIHJvd3M6IHJvd3NNZXRhZGF0YSxcbiAgICAgICAgICB2YWx1ZTogcm93cy5sZW5ndGgsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmZsYXR0ZW5Sb3dzKHBhdGgsIHJvd3MpLFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdBRERfUk9XJzoge1xuICAgICAgY29uc3QgeyBibG9ja1R5cGUsIHBhdGgsIHJvd0luZGV4OiByb3dJbmRleEZyb21BcmdzLCBzdWJGaWVsZFN0YXRlIH0gPSBhY3Rpb25cbiAgICAgIGNvbnN0IHJvd0luZGV4ID1cbiAgICAgICAgdHlwZW9mIHJvd0luZGV4RnJvbUFyZ3MgPT09ICdudW1iZXInID8gcm93SW5kZXhGcm9tQXJncyA6IHN0YXRlW3BhdGhdPy5yb3dzPy5sZW5ndGggfHwgMFxuXG4gICAgICBjb25zdCByb3dzTWV0YWRhdGEgPSBbLi4uKHN0YXRlW3BhdGhdPy5yb3dzIHx8IFtdKV1cbiAgICAgIHJvd3NNZXRhZGF0YS5zcGxpY2UoXG4gICAgICAgIHJvd0luZGV4LFxuICAgICAgICAwLFxuICAgICAgICAvLyBuZXcgcm93XG4gICAgICAgIHtcbiAgICAgICAgICBpZDogbmV3IE9iamVjdElEKCkudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgICBibG9ja1R5cGU6IGJsb2NrVHlwZSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgY2hpbGRFcnJvclBhdGhzOiBuZXcgU2V0KCksXG4gICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIClcblxuICAgICAgaWYgKGJsb2NrVHlwZSkge1xuICAgICAgICBzdWJGaWVsZFN0YXRlLmJsb2NrVHlwZSA9IHtcbiAgICAgICAgICBpbml0aWFsVmFsdWU6IGJsb2NrVHlwZSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogYmxvY2tUeXBlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBuZXcgcm93IHRvIGFycmF5IF9maWVsZCBzdGF0ZV9cbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nRmllbGRzLCByb3dzOiBzaWJsaW5nUm93cyB9ID0gc2VwYXJhdGVSb3dzKHBhdGgsIHN0YXRlKVxuICAgICAgc2libGluZ1Jvd3Muc3BsaWNlKHJvd0luZGV4LCAwLCBzdWJGaWVsZFN0YXRlKVxuXG4gICAgICBjb25zdCBuZXdTdGF0ZTogRmllbGRzID0ge1xuICAgICAgICAuLi5yZW1haW5pbmdGaWVsZHMsXG4gICAgICAgIC4uLmZsYXR0ZW5Sb3dzKHBhdGgsIHNpYmxpbmdSb3dzKSxcbiAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgLi4uc3RhdGVbcGF0aF0sXG4gICAgICAgICAgZGlzYWJsZUZvcm1EYXRhOiB0cnVlLFxuICAgICAgICAgIHJvd3M6IHJvd3NNZXRhZGF0YSxcbiAgICAgICAgICB2YWx1ZTogc2libGluZ1Jvd3MubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdSRVBMQUNFX1JPVyc6IHtcbiAgICAgIGNvbnN0IHsgYmxvY2tUeXBlLCBwYXRoLCByb3dJbmRleDogcm93SW5kZXhBcmcsIHN1YkZpZWxkU3RhdGUgfSA9IGFjdGlvblxuICAgICAgY29uc3QgeyByZW1haW5pbmdGaWVsZHMsIHJvd3M6IHNpYmxpbmdSb3dzIH0gPSBzZXBhcmF0ZVJvd3MocGF0aCwgc3RhdGUpXG4gICAgICBjb25zdCByb3dJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvd0luZGV4QXJnLCBzaWJsaW5nUm93cz8ubGVuZ3RoIC0gMSB8fCAwKSlcblxuICAgICAgY29uc3Qgcm93c01ldGFkYXRhID0gWy4uLihzdGF0ZVtwYXRoXT8ucm93cyB8fCBbXSldXG4gICAgICByb3dzTWV0YWRhdGFbcm93SW5kZXhdID0ge1xuICAgICAgICBpZDogbmV3IE9iamVjdElEKCkudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYmxvY2tUeXBlOiBibG9ja1R5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjaGlsZEVycm9yUGF0aHM6IG5ldyBTZXQoKSxcbiAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrVHlwZSkge1xuICAgICAgICBzdWJGaWVsZFN0YXRlLmJsb2NrVHlwZSA9IHtcbiAgICAgICAgICBpbml0aWFsVmFsdWU6IGJsb2NrVHlwZSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogYmxvY2tUeXBlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgZm9ybSBfZmllbGQgc3RhdGVfXG4gICAgICBzaWJsaW5nUm93c1tyb3dJbmRleF0gPSBzdWJGaWVsZFN0YXRlXG5cbiAgICAgIGNvbnN0IG5ld1N0YXRlOiBGaWVsZHMgPSB7XG4gICAgICAgIC4uLnJlbWFpbmluZ0ZpZWxkcyxcbiAgICAgICAgLi4uZmxhdHRlblJvd3MocGF0aCwgc2libGluZ1Jvd3MpLFxuICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAuLi5zdGF0ZVtwYXRoXSxcbiAgICAgICAgICBkaXNhYmxlRm9ybURhdGE6IHRydWUsXG4gICAgICAgICAgcm93czogcm93c01ldGFkYXRhLFxuICAgICAgICAgIHZhbHVlOiBzaWJsaW5nUm93cy5sZW5ndGgsXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH1cblxuICAgIGNhc2UgJ0RVUExJQ0FURV9ST1cnOiB7XG4gICAgICBjb25zdCB7IHBhdGgsIHJvd0luZGV4IH0gPSBhY3Rpb25cbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nRmllbGRzLCByb3dzIH0gPSBzZXBhcmF0ZVJvd3MocGF0aCwgc3RhdGUpXG4gICAgICBjb25zdCByb3dzTWV0YWRhdGEgPSBzdGF0ZVtwYXRoXT8ucm93cyB8fCBbXVxuXG4gICAgICBjb25zdCBkdXBsaWNhdGVSb3dNZXRhZGF0YSA9IGRlZXBDb3B5T2JqZWN0KHJvd3NNZXRhZGF0YVtyb3dJbmRleF0pXG4gICAgICBpZiAoZHVwbGljYXRlUm93TWV0YWRhdGEuaWQpIGR1cGxpY2F0ZVJvd01ldGFkYXRhLmlkID0gbmV3IE9iamVjdElEKCkudG9IZXhTdHJpbmcoKVxuXG4gICAgICBjb25zdCBkdXBsaWNhdGVSb3dTdGF0ZSA9IGRlZXBDb3B5T2JqZWN0KHJvd3Nbcm93SW5kZXhdKVxuICAgICAgaWYgKGR1cGxpY2F0ZVJvd1N0YXRlLmlkKSBkdXBsaWNhdGVSb3dTdGF0ZS5pZCA9IG5ldyBPYmplY3RJRCgpLnRvSGV4U3RyaW5nKClcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIHN1YmZpZWxkc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGR1cGxpY2F0ZVJvd1N0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEFkZCBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgc3ViZmllbGQgbmFtZXMgdG8gdW5mbGF0dGVuZWRSb3dzIGFycmF5XG4gICAgICAgIHJvd3Muc3BsaWNlKHJvd0luZGV4ICsgMSwgMCwgZHVwbGljYXRlUm93U3RhdGUpXG4gICAgICAgIHJvd3NNZXRhZGF0YS5zcGxpY2Uocm93SW5kZXggKyAxLCAwLCBkdXBsaWNhdGVSb3dNZXRhZGF0YSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIC4uLnJlbWFpbmluZ0ZpZWxkcyxcbiAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgLi4uc3RhdGVbcGF0aF0sXG4gICAgICAgICAgZGlzYWJsZUZvcm1EYXRhOiB0cnVlLFxuICAgICAgICAgIHJvd3M6IHJvd3NNZXRhZGF0YSxcbiAgICAgICAgICB2YWx1ZTogcm93cy5sZW5ndGgsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmZsYXR0ZW5Sb3dzKHBhdGgsIHJvd3MpLFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdNT1ZFX1JPVyc6IHtcbiAgICAgIGNvbnN0IHsgbW92ZUZyb21JbmRleCwgbW92ZVRvSW5kZXgsIHBhdGggfSA9IGFjdGlvblxuICAgICAgY29uc3QgeyByZW1haW5pbmdGaWVsZHMsIHJvd3MgfSA9IHNlcGFyYXRlUm93cyhwYXRoLCBzdGF0ZSlcblxuICAgICAgLy8gY29weSB0aGUgcm93IHRvIG1vdmVcbiAgICAgIGNvbnN0IGNvcHlPZk1vdmluZ1JvdyA9IHJvd3NbbW92ZUZyb21JbmRleF1cbiAgICAgIC8vIGRlbGV0ZSB0aGUgcm93IGJ5IGluZGV4XG4gICAgICByb3dzLnNwbGljZShtb3ZlRnJvbUluZGV4LCAxKVxuICAgICAgLy8gaW5zZXJ0IHJvdyBjb3B5T2ZNb3ZpbmdSb3cgYmFjayBpblxuICAgICAgcm93cy5zcGxpY2UobW92ZVRvSW5kZXgsIDAsIGNvcHlPZk1vdmluZ1JvdylcblxuICAgICAgLy8gbW9kaWZ5IGFycmF5L2Jsb2NrIGludGVybmFsIHJvdyBzdGF0ZSAoaS5lLiBjb2xsYXBzZWQsIGJsb2NrVHlwZSlcbiAgICAgIGNvbnN0IHJvd1N0YXRlQ29weSA9IFsuLi4oc3RhdGVbcGF0aF0/LnJvd3MgfHwgW10pXVxuICAgICAgY29uc3QgbW92aW5nUm93U3RhdGUgPSB7IC4uLnJvd1N0YXRlQ29weVttb3ZlRnJvbUluZGV4XSB9XG4gICAgICByb3dTdGF0ZUNvcHkuc3BsaWNlKG1vdmVGcm9tSW5kZXgsIDEpXG4gICAgICByb3dTdGF0ZUNvcHkuc3BsaWNlKG1vdmVUb0luZGV4LCAwLCBtb3ZpbmdSb3dTdGF0ZSlcblxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIC4uLnJlbWFpbmluZ0ZpZWxkcyxcbiAgICAgICAgLi4uZmxhdHRlblJvd3MocGF0aCwgcm93cyksXG4gICAgICAgIFtwYXRoXToge1xuICAgICAgICAgIC4uLnN0YXRlW3BhdGhdLFxuICAgICAgICAgIHJvd3M6IHJvd1N0YXRlQ29weSxcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfVxuXG4gICAgY2FzZSAnU0VUX1JPV19DT0xMQVBTRUQnOiB7XG4gICAgICBjb25zdCB7IGNvbGxhcHNlZCwgcGF0aCwgcm93SUQsIHNldERvY0ZpZWxkUHJlZmVyZW5jZXMgfSA9IGFjdGlvblxuXG4gICAgICBjb25zdCBhcnJheVN0YXRlID0gc3RhdGVbcGF0aF1cblxuICAgICAgY29uc3QgeyBjb2xsYXBzZWRSb3dJRHMsIG1hdGNoZWRJbmRleCB9ID0gc3RhdGVbcGF0aF0ucm93cy5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHJvdywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBpc01hdGNoaW5nUm93ID0gcm93LmlkID09PSByb3dJRFxuICAgICAgICAgIGlmIChpc01hdGNoaW5nUm93KSBhY2MubWF0Y2hlZEluZGV4ID0gaW5kZXhcblxuICAgICAgICAgIGlmICghaXNNYXRjaGluZ1JvdyAmJiByb3cuY29sbGFwc2VkKSBhY2MuY29sbGFwc2VkUm93SURzLnB1c2gocm93LmlkKVxuICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2hpbmdSb3cgJiYgY29sbGFwc2VkKSBhY2MuY29sbGFwc2VkUm93SURzLnB1c2gocm93LmlkKVxuXG4gICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY29sbGFwc2VkUm93SURzOiBbXSxcbiAgICAgICAgICBtYXRjaGVkSW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgIClcblxuICAgICAgaWYgKG1hdGNoZWRJbmRleCA+IC0xKSB7XG4gICAgICAgIGFycmF5U3RhdGUucm93c1ttYXRjaGVkSW5kZXhdLmNvbGxhcHNlZCA9IGNvbGxhcHNlZFxuICAgICAgICBzZXREb2NGaWVsZFByZWZlcmVuY2VzKHBhdGgsIHsgY29sbGFwc2VkOiBjb2xsYXBzZWRSb3dJRHMgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAuLi5hcnJheVN0YXRlLFxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVcbiAgICB9XG5cbiAgICBjYXNlICdTRVRfQUxMX1JPV1NfQ09MTEFQU0VEJzoge1xuICAgICAgY29uc3QgeyBjb2xsYXBzZWQsIHBhdGgsIHNldERvY0ZpZWxkUHJlZmVyZW5jZXMgfSA9IGFjdGlvblxuXG4gICAgICBjb25zdCB7IGNvbGxhcHNlZFJvd0lEcywgcm93cyB9ID0gc3RhdGVbcGF0aF0ucm93cy5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHJvdykgPT4ge1xuICAgICAgICAgIGlmIChjb2xsYXBzZWQpIGFjYy5jb2xsYXBzZWRSb3dJRHMucHVzaChyb3cuaWQpXG5cbiAgICAgICAgICBhY2Mucm93cy5wdXNoKHtcbiAgICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICAgIGNvbGxhcHNlZCxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY29sbGFwc2VkUm93SURzOiBbXSxcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIClcblxuICAgICAgc2V0RG9jRmllbGRQcmVmZXJlbmNlcyhwYXRoLCB7IGNvbGxhcHNlZDogY29sbGFwc2VkUm93SURzIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAuLi5zdGF0ZVtwYXRoXSxcbiAgICAgICAgICByb3dzLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBzdGF0ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImZpZWxkUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5ld1N0YXRlIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJwYXRoIiwiZmllbGQiLCJvbGRGaWVsZCIsIm5ld0ZpZWxkIiwiZXF1YWwiLCJyZXN1bHQiLCJ1c2VyIiwicmVkdWNlIiwiZmllbGRQYXRoIiwiaW5kZXhPZiIsInBhc3Nlc0NvbmRpdGlvbiIsImNvbmRpdGlvbiIsIkJvb2xlYW4iLCJyZWR1Y2VGaWVsZHNUb1ZhbHVlcyIsImdldFNpYmxpbmdEYXRhIiwia2V5IiwidmFsdWUiLCJpbmNsdWRlcyIsInJvd0luZGV4IiwicmVtYWluaW5nRmllbGRzIiwicm93cyIsInNlcGFyYXRlUm93cyIsInJvd3NNZXRhZGF0YSIsInNwbGljZSIsImRpc2FibGVGb3JtRGF0YSIsImxlbmd0aCIsImZsYXR0ZW5Sb3dzIiwiYmxvY2tUeXBlIiwicm93SW5kZXhGcm9tQXJncyIsInN1YkZpZWxkU3RhdGUiLCJpZCIsIk9iamVjdElEIiwidG9IZXhTdHJpbmciLCJ1bmRlZmluZWQiLCJjaGlsZEVycm9yUGF0aHMiLCJTZXQiLCJjb2xsYXBzZWQiLCJpbml0aWFsVmFsdWUiLCJ2YWxpZCIsInNpYmxpbmdSb3dzIiwicm93SW5kZXhBcmciLCJNYXRoIiwibWF4IiwibWluIiwiZHVwbGljYXRlUm93TWV0YWRhdGEiLCJkZWVwQ29weU9iamVjdCIsImR1cGxpY2F0ZVJvd1N0YXRlIiwia2V5cyIsIm1vdmVGcm9tSW5kZXgiLCJtb3ZlVG9JbmRleCIsImNvcHlPZk1vdmluZ1JvdyIsInJvd1N0YXRlQ29weSIsIm1vdmluZ1Jvd1N0YXRlIiwicm93SUQiLCJzZXREb2NGaWVsZFByZWZlcmVuY2VzIiwiYXJyYXlTdGF0ZSIsImNvbGxhcHNlZFJvd0lEcyIsIm1hdGNoZWRJbmRleCIsImFjYyIsInJvdyIsImluZGV4IiwiaXNNYXRjaGluZ1JvdyIsInB1c2gi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