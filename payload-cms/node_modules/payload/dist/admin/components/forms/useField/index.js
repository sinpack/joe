"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = require("react");
const _reacti18next = require("react-i18next");
const _useThrottledEffect = /*#__PURE__*/ _interop_require_default(require("../../../hooks/useThrottledEffect"));
const _Auth = require("../../utilities/Auth");
const _Config = require("../../utilities/Config");
const _DocumentInfo = require("../../utilities/DocumentInfo");
const _OperationProvider = require("../../utilities/OperationProvider");
const _context = require("../Form/context");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Get and set the value of a form field.
 *
 * @see https://payloadcms.com/docs/admin/hooks#usefield
 */ const useField = (options)=>{
    const { condition, disableFormData = false, hasRows, path, validate } = options;
    const submitted = (0, _context.useFormSubmitted)();
    const processing = (0, _context.useFormProcessing)();
    const { user } = (0, _Auth.useAuth)();
    const { id } = (0, _DocumentInfo.useDocumentInfo)();
    const operation = (0, _OperationProvider.useOperation)();
    const field = (0, _context.useFormFields)(([fields])=>fields[path]);
    const { t } = (0, _reacti18next.useTranslation)();
    const dispatchField = (0, _context.useFormFields)(([_, dispatch])=>dispatch);
    const config = (0, _Config.useConfig)();
    const { getData, getDataByPath, getSiblingData, setModified } = (0, _context.useForm)();
    const value = field?.value;
    const initialValue = field?.initialValue;
    const valid = typeof field?.valid === 'boolean' ? field.valid : true;
    const showError = valid === false && submitted;
    const prevValid = (0, _react.useRef)(valid);
    const prevValue = (0, _react.useRef)(value);
    // Method to return from `useField`, used to
    // update field values from field component(s)
    const setValue = (0, _react.useCallback)((e, disableModifyingForm = false)=>{
        const val = e && e.target ? e.target.value : e;
        if (!disableModifyingForm) {
            if (typeof setModified === 'function') {
                // Update modified state after field value comes back
                // to avoid cursor jump caused by state value / DOM mismatch
                setTimeout(()=>{
                    setModified(true);
                }, 10);
            }
        }
        dispatchField({
            type: 'UPDATE',
            disableFormData: disableFormData || hasRows && val > 0,
            path,
            value: val
        });
    }, [
        setModified,
        path,
        dispatchField,
        disableFormData,
        hasRows
    ]);
    // Store result from hook as ref
    // to prevent unnecessary rerenders
    const result = (0, _react.useMemo)(()=>({
            errorMessage: field?.errorMessage,
            formProcessing: processing,
            formSubmitted: submitted,
            initialValue,
            rows: field?.rows,
            setValue,
            showError,
            valid: field?.valid,
            value
        }), [
        field?.errorMessage,
        field?.rows,
        field?.valid,
        processing,
        setValue,
        showError,
        submitted,
        value,
        initialValue
    ]);
    // Throttle the validate function
    (0, _useThrottledEffect.default)(()=>{
        const validateField = async ()=>{
            let valueToValidate = value;
            if (field?.rows && Array.isArray(field.rows)) {
                valueToValidate = getDataByPath(path);
            }
            let errorMessage;
            let valid = false;
            const validationResult = typeof validate === 'function' ? await validate(valueToValidate, {
                id,
                config,
                data: getData(),
                operation,
                previousValue: prevValue.current,
                siblingData: getSiblingData(path),
                t,
                user
            }) : true;
            if (typeof validationResult === 'string') {
                errorMessage = validationResult;
                valid = false;
            } else {
                valid = validationResult;
                errorMessage = undefined;
            }
            // Only dispatch if the validation result has changed
            // This will prevent unnecessary rerenders
            if (valid !== prevValid.current) {
                prevValid.current = valid;
                if (typeof dispatchField === 'function') {
                    dispatchField({
                        type: 'UPDATE',
                        condition,
                        disableFormData: disableFormData || (hasRows ? typeof value === 'number' && value > 0 : false),
                        errorMessage,
                        path,
                        previousValue: prevValue.current,
                        rows: field?.rows,
                        valid,
                        validate,
                        value
                    });
                }
            }
        };
        void validateField();
    }, 150, [
        value,
        condition,
        disableFormData,
        dispatchField,
        getData,
        getSiblingData,
        getDataByPath,
        id,
        operation,
        path,
        user,
        validate,
        field?.rows
    ]);
    return result;
};
const _default = useField;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL3VzZUZpZWxkL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRUeXBlLCBPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHVzZVRocm90dGxlZEVmZmVjdCBmcm9tICcuLi8uLi8uLi9ob29rcy91c2VUaHJvdHRsZWRFZmZlY3QnXG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL0F1dGgnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IHsgdXNlRG9jdW1lbnRJbmZvIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL0RvY3VtZW50SW5mbydcbmltcG9ydCB7IHVzZU9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9PcGVyYXRpb25Qcm92aWRlcidcbmltcG9ydCB7IHVzZUZvcm0sIHVzZUZvcm1GaWVsZHMsIHVzZUZvcm1Qcm9jZXNzaW5nLCB1c2VGb3JtU3VibWl0dGVkIH0gZnJvbSAnLi4vRm9ybS9jb250ZXh0J1xuXG4vKipcbiAqIEdldCBhbmQgc2V0IHRoZSB2YWx1ZSBvZiBhIGZvcm0gZmllbGQuXG4gKlxuICogQHNlZSBodHRwczovL3BheWxvYWRjbXMuY29tL2RvY3MvYWRtaW4vaG9va3MjdXNlZmllbGRcbiAqL1xuY29uc3QgdXNlRmllbGQgPSA8VCw+KG9wdGlvbnM6IE9wdGlvbnMpOiBGaWVsZFR5cGU8VD4gPT4ge1xuICBjb25zdCB7IGNvbmRpdGlvbiwgZGlzYWJsZUZvcm1EYXRhID0gZmFsc2UsIGhhc1Jvd3MsIHBhdGgsIHZhbGlkYXRlIH0gPSBvcHRpb25zXG5cbiAgY29uc3Qgc3VibWl0dGVkID0gdXNlRm9ybVN1Ym1pdHRlZCgpXG4gIGNvbnN0IHByb2Nlc3NpbmcgPSB1c2VGb3JtUHJvY2Vzc2luZygpXG4gIGNvbnN0IHsgdXNlciB9ID0gdXNlQXV0aCgpXG4gIGNvbnN0IHsgaWQgfSA9IHVzZURvY3VtZW50SW5mbygpXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHVzZU9wZXJhdGlvbigpXG4gIGNvbnN0IGZpZWxkID0gdXNlRm9ybUZpZWxkcygoW2ZpZWxkc10pID0+IGZpZWxkc1twYXRoXSlcbiAgY29uc3QgeyB0IH0gPSB1c2VUcmFuc2xhdGlvbigpXG4gIGNvbnN0IGRpc3BhdGNoRmllbGQgPSB1c2VGb3JtRmllbGRzKChbXywgZGlzcGF0Y2hdKSA9PiBkaXNwYXRjaClcbiAgY29uc3QgY29uZmlnID0gdXNlQ29uZmlnKClcblxuICBjb25zdCB7IGdldERhdGEsIGdldERhdGFCeVBhdGgsIGdldFNpYmxpbmdEYXRhLCBzZXRNb2RpZmllZCB9ID0gdXNlRm9ybSgpXG5cbiAgY29uc3QgdmFsdWUgPSBmaWVsZD8udmFsdWUgYXMgVFxuICBjb25zdCBpbml0aWFsVmFsdWUgPSBmaWVsZD8uaW5pdGlhbFZhbHVlIGFzIFRcbiAgY29uc3QgdmFsaWQgPSB0eXBlb2YgZmllbGQ/LnZhbGlkID09PSAnYm9vbGVhbicgPyBmaWVsZC52YWxpZCA6IHRydWVcbiAgY29uc3Qgc2hvd0Vycm9yID0gdmFsaWQgPT09IGZhbHNlICYmIHN1Ym1pdHRlZFxuXG4gIGNvbnN0IHByZXZWYWxpZCA9IHVzZVJlZih2YWxpZClcbiAgY29uc3QgcHJldlZhbHVlID0gdXNlUmVmKHZhbHVlKVxuXG4gIC8vIE1ldGhvZCB0byByZXR1cm4gZnJvbSBgdXNlRmllbGRgLCB1c2VkIHRvXG4gIC8vIHVwZGF0ZSBmaWVsZCB2YWx1ZXMgZnJvbSBmaWVsZCBjb21wb25lbnQocylcbiAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICAoZSwgZGlzYWJsZU1vZGlmeWluZ0Zvcm0gPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gZSAmJiBlLnRhcmdldCA/IGUudGFyZ2V0LnZhbHVlIDogZVxuXG4gICAgICBpZiAoIWRpc2FibGVNb2RpZnlpbmdGb3JtKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0TW9kaWZpZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgbW9kaWZpZWQgc3RhdGUgYWZ0ZXIgZmllbGQgdmFsdWUgY29tZXMgYmFja1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGN1cnNvciBqdW1wIGNhdXNlZCBieSBzdGF0ZSB2YWx1ZSAvIERPTSBtaXNtYXRjaFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0TW9kaWZpZWQodHJ1ZSlcbiAgICAgICAgICB9LCAxMClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaEZpZWxkKHtcbiAgICAgICAgdHlwZTogJ1VQREFURScsXG4gICAgICAgIGRpc2FibGVGb3JtRGF0YTogZGlzYWJsZUZvcm1EYXRhIHx8IChoYXNSb3dzICYmIHZhbCA+IDApLFxuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtzZXRNb2RpZmllZCwgcGF0aCwgZGlzcGF0Y2hGaWVsZCwgZGlzYWJsZUZvcm1EYXRhLCBoYXNSb3dzXSxcbiAgKVxuXG4gIC8vIFN0b3JlIHJlc3VsdCBmcm9tIGhvb2sgYXMgcmVmXG4gIC8vIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXG4gIGNvbnN0IHJlc3VsdDogRmllbGRUeXBlPFQ+ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgZXJyb3JNZXNzYWdlOiBmaWVsZD8uZXJyb3JNZXNzYWdlLFxuICAgICAgZm9ybVByb2Nlc3Npbmc6IHByb2Nlc3NpbmcsXG4gICAgICBmb3JtU3VibWl0dGVkOiBzdWJtaXR0ZWQsXG4gICAgICBpbml0aWFsVmFsdWUsXG4gICAgICByb3dzOiBmaWVsZD8ucm93cyxcbiAgICAgIHNldFZhbHVlLFxuICAgICAgc2hvd0Vycm9yLFxuICAgICAgdmFsaWQ6IGZpZWxkPy52YWxpZCxcbiAgICAgIHZhbHVlLFxuICAgIH0pLFxuICAgIFtcbiAgICAgIGZpZWxkPy5lcnJvck1lc3NhZ2UsXG4gICAgICBmaWVsZD8ucm93cyxcbiAgICAgIGZpZWxkPy52YWxpZCxcbiAgICAgIHByb2Nlc3NpbmcsXG4gICAgICBzZXRWYWx1ZSxcbiAgICAgIHNob3dFcnJvcixcbiAgICAgIHN1Ym1pdHRlZCxcbiAgICAgIHZhbHVlLFxuICAgICAgaW5pdGlhbFZhbHVlLFxuICAgIF0sXG4gIClcblxuICAvLyBUaHJvdHRsZSB0aGUgdmFsaWRhdGUgZnVuY3Rpb25cbiAgdXNlVGhyb3R0bGVkRWZmZWN0KFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlRmllbGQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZVRvVmFsaWRhdGUgPSB2YWx1ZVxuXG4gICAgICAgIGlmIChmaWVsZD8ucm93cyAmJiBBcnJheS5pc0FycmF5KGZpZWxkLnJvd3MpKSB7XG4gICAgICAgICAgdmFsdWVUb1ZhbGlkYXRlID0gZ2V0RGF0YUJ5UGF0aChwYXRoKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICAgIGxldCB2YWxpZDogYm9vbGVhbiB8IHN0cmluZyA9IGZhbHNlXG5cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9XG4gICAgICAgICAgdHlwZW9mIHZhbGlkYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IHZhbGlkYXRlKHZhbHVlVG9WYWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICBkYXRhOiBnZXREYXRhKCksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHByZXZWYWx1ZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHNpYmxpbmdEYXRhOiBnZXRTaWJsaW5nRGF0YShwYXRoKSxcbiAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHRydWVcblxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZCA9IHZhbGlkYXRpb25SZXN1bHRcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgZGlzcGF0Y2ggaWYgdGhlIHZhbGlkYXRpb24gcmVzdWx0IGhhcyBjaGFuZ2VkXG4gICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlcmVuZGVyc1xuICAgICAgICBpZiAodmFsaWQgIT09IHByZXZWYWxpZC5jdXJyZW50KSB7XG4gICAgICAgICAgcHJldlZhbGlkLmN1cnJlbnQgPSB2YWxpZFxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkaXNwYXRjaEZpZWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkaXNwYXRjaEZpZWxkKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1VQREFURScsXG4gICAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgZGlzYWJsZUZvcm1EYXRhOlxuICAgICAgICAgICAgICAgIGRpc2FibGVGb3JtRGF0YSB8fCAoaGFzUm93cyA/IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAwIDogZmFsc2UpLFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHByZXZWYWx1ZS5jdXJyZW50LFxuICAgICAgICAgICAgICByb3dzOiBmaWVsZD8ucm93cyxcbiAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgIHZhbGlkYXRlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgdmFsaWRhdGVGaWVsZCgpXG4gICAgfSxcbiAgICAxNTAsXG4gICAgW1xuICAgICAgdmFsdWUsXG4gICAgICBjb25kaXRpb24sXG4gICAgICBkaXNhYmxlRm9ybURhdGEsXG4gICAgICBkaXNwYXRjaEZpZWxkLFxuICAgICAgZ2V0RGF0YSxcbiAgICAgIGdldFNpYmxpbmdEYXRhLFxuICAgICAgZ2V0RGF0YUJ5UGF0aCxcbiAgICAgIGlkLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgcGF0aCxcbiAgICAgIHVzZXIsXG4gICAgICB2YWxpZGF0ZSxcbiAgICAgIGZpZWxkPy5yb3dzLFxuICAgIF0sXG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZpZWxkXG4iXSwibmFtZXMiOlsidXNlRmllbGQiLCJvcHRpb25zIiwiY29uZGl0aW9uIiwiZGlzYWJsZUZvcm1EYXRhIiwiaGFzUm93cyIsInBhdGgiLCJ2YWxpZGF0ZSIsInN1Ym1pdHRlZCIsInVzZUZvcm1TdWJtaXR0ZWQiLCJwcm9jZXNzaW5nIiwidXNlRm9ybVByb2Nlc3NpbmciLCJ1c2VyIiwidXNlQXV0aCIsImlkIiwidXNlRG9jdW1lbnRJbmZvIiwib3BlcmF0aW9uIiwidXNlT3BlcmF0aW9uIiwiZmllbGQiLCJ1c2VGb3JtRmllbGRzIiwiZmllbGRzIiwidCIsInVzZVRyYW5zbGF0aW9uIiwiZGlzcGF0Y2hGaWVsZCIsIl8iLCJkaXNwYXRjaCIsImNvbmZpZyIsInVzZUNvbmZpZyIsImdldERhdGEiLCJnZXREYXRhQnlQYXRoIiwiZ2V0U2libGluZ0RhdGEiLCJzZXRNb2RpZmllZCIsInVzZUZvcm0iLCJ2YWx1ZSIsImluaXRpYWxWYWx1ZSIsInZhbGlkIiwic2hvd0Vycm9yIiwicHJldlZhbGlkIiwidXNlUmVmIiwicHJldlZhbHVlIiwic2V0VmFsdWUiLCJ1c2VDYWxsYmFjayIsImUiLCJkaXNhYmxlTW9kaWZ5aW5nRm9ybSIsInZhbCIsInRhcmdldCIsInNldFRpbWVvdXQiLCJ0eXBlIiwicmVzdWx0IiwidXNlTWVtbyIsImVycm9yTWVzc2FnZSIsImZvcm1Qcm9jZXNzaW5nIiwiZm9ybVN1Ym1pdHRlZCIsInJvd3MiLCJ1c2VUaHJvdHRsZWRFZmZlY3QiLCJ2YWxpZGF0ZUZpZWxkIiwidmFsdWVUb1ZhbGlkYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRhdGlvblJlc3VsdCIsImRhdGEiLCJwcmV2aW91c1ZhbHVlIiwiY3VycmVudCIsInNpYmxpbmdEYXRhIiwidW5kZWZpbmVkIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7OytCQThLQTs7O2VBQUE7Ozt1QkE5SzZDOzhCQUNkOzJFQUlBO3NCQUNQO3dCQUNFOzhCQUNNO21DQUNIO3lCQUMrQzs7Ozs7O0FBRTVFOzs7O0NBSUMsR0FDRCxNQUFNQSxXQUFXLENBQUtDO0lBQ3BCLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxrQkFBa0IsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFLEdBQUdMO0lBRXhFLE1BQU1NLFlBQVlDLElBQUFBLHlCQUFnQjtJ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