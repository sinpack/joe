"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ArrayRow", {
    enumerable: true,
    get: function() {
        return ArrayRow;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _reacti18next = require("react-i18next");
const _getTranslation = require("../../../../../utilities/getTranslation");
const _ArrayAction = require("../../../elements/ArrayAction");
const _Collapsible = require("../../../elements/Collapsible");
const _ErrorPill = require("../../../elements/ErrorPill");
const _context = require("../../Form/context");
const _createNestedFieldPath = require("../../Form/createNestedFieldPath");
const _RenderFields = /*#__PURE__*/ _interop_require_default(require("../../RenderFields"));
const _RowLabel = require("../../RowLabel");
const _HiddenInput = /*#__PURE__*/ _interop_require_default(require("../HiddenInput"));
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const baseClass = 'array-field';
const ArrayRow = ({ CustomRowLabel, addRow, attributes, duplicateRow, fieldTypes, fields, forceRender = false, hasMaxRows, indexPath, isSortable, labels, listeners, moveRow, path: parentPath, permissions, readOnly, removeRow, row, rowCount, rowIndex, setCollapse, setNodeRef, transform })=>{
    const path = `${parentPath}.${rowIndex}`;
    const { i18n } = (0, _reacti18next.useTranslation)();
    const hasSubmitted = (0, _context.useFormSubmitted)();
    const fallbackLabel = `${(0, _getTranslation.getTranslation)(labels.singular, i18n)} ${String(rowIndex + 1).padStart(2, '0')}`;
    const childErrorPathsCount = row.childErrorPaths?.size;
    const fieldHasErrors = hasSubmitted && childErrorPathsCount > 0;
    const classNames = [
        `${baseClass}__row`,
        fieldHasErrors ? `${baseClass}__row--has-errors` : `${baseClass}__row--no-errors`
    ].filter(Boolean).join(' ');
    return /*#__PURE__*/ _react.default.createElement("div", {
        id: `${parentPath.split('.').join('-')}-row-${rowIndex}`,
        key: `${parentPath}-row-${row.id}`,
        ref: setNodeRef,
        style: {
            transform
        }
    }, /*#__PURE__*/ _react.default.createElement(_Collapsible.Collapsible, {
        actions: !readOnly ? /*#__PURE__*/ _react.default.createElement(_ArrayAction.ArrayAction, {
            addRow: addRow,
            duplicateRow: duplicateRow,
            hasMaxRows: hasMaxRows,
            index: rowIndex,
            isSortable: isSortable,
            moveRow: moveRow,
            removeRow: removeRow,
            rowCount: rowCount
        }) : undefined,
        className: classNames,
        collapsed: row.collapsed,
        collapsibleStyle: fieldHasErrors ? 'error' : 'default',
        dragHandleProps: isSortable ? {
            id: row.id,
            attributes,
            listeners
        } : undefined,
        header: /*#__PURE__*/ _react.default.createElement("div", {
            className: `${baseClass}__row-header`
        }, /*#__PURE__*/ _react.default.createElement(_RowLabel.RowLabel, {
            label: CustomRowLabel || fallbackLabel,
            path: path,
            rowNumber: rowIndex + 1
        }), fieldHasErrors && /*#__PURE__*/ _react.default.createElement(_ErrorPill.ErrorPill, {
            count: childErrorPathsCount,
            withMessage: true
        })),
        onToggle: (collapsed)=>setCollapse(row.id, collapsed)
    }, /*#__PURE__*/ _react.default.createElement(_HiddenInput.default, {
        name: `${path}.id`,
        value: row.id
    }), /*#__PURE__*/ _react.default.createElement(_RenderFields.default, {
        className: `${baseClass}__fields`,
        fieldSchema: fields.map((field)=>({
                ...field,
                path: (0, _createNestedFieldPath.createNestedFieldPath)(path, field)
            })),
        fieldTypes: fieldTypes,
        forceRender: forceRender,
        indexPath: indexPath,
        margins: "small",
        permissions: permissions?.fields,
        readOnly: readOnly
    })));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL2ZpZWxkLXR5cGVzL0FycmF5L0FycmF5Um93LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgVXNlRHJhZ2dhYmxlU29ydGFibGVSZXR1cm4gfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9EcmFnZ2FibGVTb3J0YWJsZS91c2VEcmFnZ2FibGVTb3J0YWJsZS90eXBlcydcbmltcG9ydCB0eXBlIHsgUm93IH0gZnJvbSAnLi4vLi4vRm9ybS90eXBlcydcbmltcG9ydCB0eXBlIHsgUm93TGFiZWwgYXMgUm93TGFiZWxUeXBlIH0gZnJvbSAnLi4vLi4vUm93TGFiZWwvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlsaXRpZXMvZ2V0VHJhbnNsYXRpb24nXG5pbXBvcnQgeyBBcnJheUFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0FycmF5QWN0aW9uJ1xuaW1wb3J0IHsgQ29sbGFwc2libGUgfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9Db2xsYXBzaWJsZSdcbmltcG9ydCB7IEVycm9yUGlsbCB9IGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0Vycm9yUGlsbCdcbmltcG9ydCB7IHVzZUZvcm1TdWJtaXR0ZWQgfSBmcm9tICcuLi8uLi9Gb3JtL2NvbnRleHQnXG5pbXBvcnQgeyBjcmVhdGVOZXN0ZWRGaWVsZFBhdGggfSBmcm9tICcuLi8uLi9Gb3JtL2NyZWF0ZU5lc3RlZEZpZWxkUGF0aCdcbmltcG9ydCBSZW5kZXJGaWVsZHMgZnJvbSAnLi4vLi4vUmVuZGVyRmllbGRzJ1xuaW1wb3J0IHsgUm93TGFiZWwgfSBmcm9tICcuLi8uLi9Sb3dMYWJlbCdcbmltcG9ydCBIaWRkZW5JbnB1dCBmcm9tICcuLi9IaWRkZW5JbnB1dCdcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnYXJyYXktZmllbGQnXG5cbnR5cGUgQXJyYXlSb3dQcm9wcyA9IFVzZURyYWdnYWJsZVNvcnRhYmxlUmV0dXJuICZcbiAgUGljazxQcm9wcywgJ2ZpZWxkVHlwZXMnIHwgJ2ZpZWxkcycgfCAnaW5kZXhQYXRoJyB8ICdsYWJlbHMnIHwgJ3BhdGgnIHwgJ3Blcm1pc3Npb25zJz4gJiB7XG4gICAgQ3VzdG9tUm93TGFiZWw/OiBSb3dMYWJlbFR5cGVcbiAgICBhZGRSb3c6IChyb3dJbmRleDogbnVtYmVyKSA9PiB2b2lkXG4gICAgZHVwbGljYXRlUm93OiAocm93SW5kZXg6IG51bWJlcikgPT4gdm9pZFxuICAgIGZvcmNlUmVuZGVyPzogYm9vbGVhblxuICAgIGhhc01heFJvd3M/OiBib29sZWFuXG4gICAgaXNTb3J0YWJsZTogYm9vbGVhblxuICAgIG1vdmVSb3c6IChmcm9tSW5kZXg6IG51bWJlciwgdG9JbmRleDogbnVtYmVyKSA9PiB2b2lkXG4gICAgcmVhZE9ubHk/OiBib29sZWFuXG4gICAgcmVtb3ZlUm93OiAocm93SW5kZXg6IG51bWJlcikgPT4gdm9pZFxuICAgIHJvdzogUm93XG4gICAgcm93Q291bnQ6IG51bWJlclxuICAgIHJvd0luZGV4OiBudW1iZXJcbiAgICBzZXRDb2xsYXBzZTogKHJvd0lEOiBzdHJpbmcsIGNvbGxhcHNlZDogYm9vbGVhbikgPT4gdm9pZFxuICB9XG5leHBvcnQgY29uc3QgQXJyYXlSb3c6IFJlYWN0LkZDPEFycmF5Um93UHJvcHM+ID0gKHtcbiAgQ3VzdG9tUm93TGFiZWwsXG4gIGFkZFJvdyxcbiAgYXR0cmlidXRlcyxcbiAgZHVwbGljYXRlUm93LFxuICBmaWVsZFR5cGVzLFxuICBmaWVsZHMsXG4gIGZvcmNlUmVuZGVyID0gZmFsc2UsXG4gIGhhc01heFJvd3MsXG4gIGluZGV4UGF0aCxcbiAgaXNTb3J0YWJsZSxcbiAgbGFiZWxzLFxuICBsaXN0ZW5lcnMsXG4gIG1vdmVSb3csXG4gIHBhdGg6IHBhcmVudFBhdGgsXG4gIHBlcm1pc3Npb25zLFxuICByZWFkT25seSxcbiAgcmVtb3ZlUm93LFxuICByb3csXG4gIHJvd0NvdW50LFxuICByb3dJbmRleCxcbiAgc2V0Q29sbGFwc2UsXG4gIHNldE5vZGVSZWYsXG4gIHRyYW5zZm9ybSxcbn0pID0+IHtcbiAgY29uc3QgcGF0aCA9IGAke3BhcmVudFBhdGh9LiR7cm93SW5kZXh9YFxuICBjb25zdCB7IGkxOG4gfSA9IHVzZVRyYW5zbGF0aW9uKClcbiAgY29uc3QgaGFzU3VibWl0dGVkID0gdXNlRm9ybVN1Ym1pdHRlZCgpXG5cbiAgY29uc3QgZmFsbGJhY2tMYWJlbCA9IGAke2dldFRyYW5zbGF0aW9uKGxhYmVscy5zaW5ndWxhciwgaTE4bil9ICR7U3RyaW5nKHJvd0luZGV4ICsgMSkucGFkU3RhcnQoXG4gICAgMixcbiAgICAnMCcsXG4gICl9YFxuXG4gIGNvbnN0IGNoaWxkRXJyb3JQYXRoc0NvdW50ID0gcm93LmNoaWxkRXJyb3JQYXRocz8uc2l6ZVxuICBjb25zdCBmaWVsZEhhc0Vycm9ycyA9IGhhc1N1Ym1pdHRlZCAmJiBjaGlsZEVycm9yUGF0aHNDb3VudCA+IDBcblxuICBjb25zdCBjbGFzc05hbWVzID0gW1xuICAgIGAke2Jhc2VDbGFzc31fX3Jvd2AsXG4gICAgZmllbGRIYXNFcnJvcnMgPyBgJHtiYXNlQ2xhc3N9X19yb3ctLWhhcy1lcnJvcnNgIDogYCR7YmFzZUNsYXNzfV9fcm93LS1uby1lcnJvcnNgLFxuICBdXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKCcgJylcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGlkPXtgJHtwYXJlbnRQYXRoLnNwbGl0KCcuJykuam9pbignLScpfS1yb3ctJHtyb3dJbmRleH1gfVxuICAgICAga2V5PXtgJHtwYXJlbnRQYXRofS1yb3ctJHtyb3cuaWR9YH1cbiAgICAgIHJlZj17c2V0Tm9kZVJlZn1cbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPENvbGxhcHNpYmxlXG4gICAgICAgIGFjdGlvbnM9e1xuICAgICAgICAgICFyZWFkT25seSA/IChcbiAgICAgICAgICAgIDxBcnJheUFjdGlvblxuICAgICAgICAgICAgICBhZGRSb3c9e2FkZFJvd31cbiAgICAgICAgICAgICAgZHVwbGljYXRlUm93PXtkdXBsaWNhdGVSb3d9XG4gICAgICAgICAgICAgIGhhc01heFJvd3M9e2hhc01heFJvd3N9XG4gICAgICAgICAgICAgIGluZGV4PXtyb3dJbmRleH1cbiAgICAgICAgICAgICAgaXNTb3J0YWJsZT17aXNTb3J0YWJsZX1cbiAgICAgICAgICAgICAgbW92ZVJvdz17bW92ZVJvd31cbiAgICAgICAgICAgICAgcmVtb3ZlUm93PXtyZW1vdmVSb3d9XG4gICAgICAgICAgICAgIHJvd0NvdW50PXtyb3dDb3VudH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc31cbiAgICAgICAgY29sbGFwc2VkPXtyb3cuY29sbGFwc2VkfVxuICAgICAgICBjb2xsYXBzaWJsZVN0eWxlPXtmaWVsZEhhc0Vycm9ycyA/ICdlcnJvcicgOiAnZGVmYXVsdCd9XG4gICAgICAgIGRyYWdIYW5kbGVQcm9wcz17XG4gICAgICAgICAgaXNTb3J0YWJsZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXI9e1xuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19yb3ctaGVhZGVyYH0+XG4gICAgICAgICAgICA8Um93TGFiZWxcbiAgICAgICAgICAgICAgbGFiZWw9e0N1c3RvbVJvd0xhYmVsIHx8IGZhbGxiYWNrTGFiZWx9XG4gICAgICAgICAgICAgIHBhdGg9e3BhdGh9XG4gICAgICAgICAgICAgIHJvd051bWJlcj17cm93SW5kZXggKyAxfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtmaWVsZEhhc0Vycm9ycyAmJiA8RXJyb3JQaWxsIGNvdW50PXtjaGlsZEVycm9yUGF0aHNDb3VudH0gd2l0aE1lc3NhZ2UgLz59XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIH1cbiAgICAgICAgb25Ub2dnbGU9eyhjb2xsYXBzZWQpID0+IHNldENvbGxhcHNlKHJvdy5pZCwgY29sbGFwc2VkKX1cbiAgICAgID5cbiAgICAgICAgPEhpZGRlbklucHV0IG5hbWU9e2Ake3BhdGh9LmlkYH0gdmFsdWU9e3Jvdy5pZH0gLz5cbiAgICAgICAgPFJlbmRlckZpZWxkc1xuICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZmllbGRzYH1cbiAgICAgICAgICBmaWVsZFNjaGVtYT17ZmllbGRzLm1hcCgoZmllbGQpID0+ICh7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIHBhdGg6IGNyZWF0ZU5lc3RlZEZpZWxkUGF0aChwYXRoLCBmaWVsZCksXG4gICAgICAgICAgfSkpfVxuICAgICAgICAgIGZpZWxkVHlwZXM9e2ZpZWxkVHlwZXN9XG4gICAgICAgICAgZm9yY2VSZW5kZXI9e2ZvcmNlUmVuZGVyfVxuICAgICAgICAgIGluZGV4UGF0aD17aW5kZXhQYXRofVxuICAgICAgICAgIG1hcmdpbnM9XCJzbWFsbFwiXG4gICAgICAgICAgcGVybWlzc2lvbnM9e3Blcm1pc3Npb25zPy5maWVsZHN9XG4gICAgICAgICAgcmVhZE9ubHk9e3JlYWRPbmx5fVxuICAgICAgICAvPlxuICAgICAgPC9Db2xsYXBzaWJsZT5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkFycmF5Um93IiwiYmFzZUNsYXNzIiwiQ3VzdG9tUm93TGFiZWwiLCJhZGRSb3ciLCJhdHRyaWJ1dGVzIiwiZHVwbGljYXRlUm93IiwiZmllbGRUeXBlcyIsImZpZWxkcyIsImZvcmNlUmVuZGVyIiwiaGFzTWF4Um93cyIsImluZGV4UGF0aCIsImlzU29ydGFibGUiLCJsYWJlbHMiLCJsaXN0ZW5lcnMiLCJtb3ZlUm93IiwicGF0aCIsInBhcmVudFBhdGgiLCJwZXJtaXNzaW9ucyIsInJlYWRPbmx5IiwicmVtb3ZlUm93Iiwicm93Iiwicm93Q291bnQiLCJyb3dJbmRleCIsInNldENvbGxhcHNlIiwic2V0Tm9kZVJlZiIsInRyYW5zZm9ybSIsImkxOG4iLCJ1c2VUcmFuc2xhdGlvbiIsImhhc1N1Ym1pdHRlZCIsInVzZUZvcm1TdWJtaXR0ZWQiLCJmYWxsYmFja0xhYmVsIiwiZ2V0VHJhbnNsYXRpb24iLCJzaW5ndWxhciIsIlN0cmluZyIsInBhZFN0YXJ0IiwiY2hpbGRFcnJvclBhdGhzQ291bnQiLCJjaGlsZEVycm9yUGF0aHMiLCJzaXplIiwiZmllbGRIYXNFcnJvcnMiLCJjbGFzc05hbWVzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkaXYiLCJpZCIsInNwbGl0Iiwia2V5IiwicmVmIiwic3R5bGUiLCJDb2xsYXBzaWJsZSIsImFjdGlvbnMiLCJBcnJheUFjdGlvbiIsImluZGV4IiwidW5kZWZpbmVkIiwiY2xhc3NOYW1lIiwiY29sbGFwc2VkIiwiY29sbGFwc2libGVTdHlsZSIsImRyYWdIYW5kbGVQcm9wcyIsImhlYWRlciIsIlJvd0xhYmVsIiwibGFiZWwiLCJyb3dOdW1iZXIiLCJFcnJvclBpbGwiLCJjb3VudCIsIndpdGhNZXNzYWdlIiwib25Ub2dnbGUiLCJIaWRkZW5JbnB1dCIsIm5hbWUiLCJ2YWx1ZSIsIlJlbmRlckZpZWxkcyIsImZpZWxkU2NoZW1hIiwibWFwIiwiZmllbGQiLCJjcmVh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