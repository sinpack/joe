"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _types = require("../../../../fields/config/types");
const _getTranslation = require("../../../../utilities/getTranslation");
const _useIntersect = /*#__PURE__*/ _interop_require_default(require("../../../hooks/useIntersect"));
const _OperationProvider = require("../../utilities/OperationProvider");
const _RenderCustomComponent = /*#__PURE__*/ _interop_require_default(require("../../utilities/RenderCustomComponent"));
const _filterFields = require("./filterFields");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'render-fields';
const intersectionObserverOptions = {
    rootMargin: '1000px'
};
/**
 * If you send `fields` through, it will render those fields explicitly
 * Otherwise, it will reduce your fields using the other provided props
 * This is so that we can conditionally render fields before reducing them, if desired
 * See the sidebar in '../collections/Edit/Default/index.tsx' for an example
 *
 * The state/data for the fields it renders is not managed by this component. Instead, every component it renders has
 * their own handling of their own value, usually through the useField hook. This hook will get the field's value
 * from the Form the field is in, using the field's path.
 *
 * Thus, if you would like to set the value of a field you render here, you must do so in the Form that contains the field, or in the
 * Field component itself.
 *
 * All this component does is render the field's Field Components, and pass them the props they need to function.
 **/ const RenderFields = (props)=>{
    const { className, fieldTypes, forceRender, margins } = props;
    const { i18n, t } = (0, _reacti18next.useTranslation)('general');
    const [hasRendered, setHasRendered] = (0, _react.useState)(Boolean(forceRender));
    const [intersectionRef, entry] = (0, _useIntersect.default)(intersectionObserverOptions, forceRender);
    const isIntersecting = Boolean(entry?.isIntersecting);
    const isAboveViewport = entry?.boundingClientRect?.top < 0;
    const shouldRender = forceRender || isIntersecting || isAboveViewport;
    const operation = (0, _OperationProvider.useOperation)();
    (0, _react.useEffect)(()=>{
        if (shouldRender && !hasRendered) {
            setHasRendered(true);
        }
    }, [
        shouldRender,
        hasRendered
    ]);
    let fieldsToRender = 'fields' in props ? props?.fields : null;
    if (!fieldsToRender && 'fieldSchema' in props) {
        const { fieldSchema, fieldTypes, filter, permissions, readOnly: readOnlyOverride } = props;
        fieldsToRender = (0, _filterFields.filterFields)({
            fieldSchema,
            fieldTypes,
            filter,
            operation,
            permissions,
            readOnly: readOnlyOverride
        });
    }
    if (fieldsToRender) {
        return /*#__PURE__*/ _react.default.createElement("div", {
            className: [
                baseClass,
                className,
                margins && `${baseClass}--margins-${margins}`,
                margins === false && `${baseClass}--margins-none`
            ].filter(Boolean).join(' '),
            ref: intersectionRef
        }, hasRendered && fieldsToRender.map((reducedField, fieldIndex)=>{
            const { FieldComponent, field, fieldIsPresentational, fieldPermissions, isFieldAffectingData, readOnly } = reducedField;
            if (fieldIsPresentational) {
                return /*#__PURE__*/ _react.default.createElement(FieldComponent, {
                    key: fieldIndex,
                    ...field
                });
            }
            if (field) {
                return /*#__PURE__*/ _react.default.createElement(_RenderCustomComponent.default, {
                    CustomComponent: field?.admin?.components?.Field,
                    DefaultComponent: FieldComponent,
                    componentProps: {
                        ...field,
                        admin: {
                            ...field.admin || {},
                            readOnly
                        },
                        fieldTypes,
                        forceRender,
                        indexPath: 'indexPath' in props ? `${props?.indexPath}.${fieldIndex}` : `${fieldIndex}`,
                        path: field.path || (isFieldAffectingData && 'name' in field ? field.name : ''),
                        permissions: fieldPermissions
                    },
                    key: fieldIndex
                });
            }
            return /*#__PURE__*/ _react.default.createElement("div", {
                className: "missing-field",
                key: fieldIndex
            }, t('error:noMatchedField', {
                label: (0, _types.fieldAffectsData)(field) ? (0, _getTranslation.getTranslation)(field.label || field.name, i18n) : field.path
            }));
        }));
    }
    return null;
};
const _default = RenderFields;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL1JlbmRlckZpZWxkcy9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGZpZWxkQWZmZWN0c0RhdGEgfSBmcm9tICcuLi8uLi8uLi8uLi9maWVsZHMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvZ2V0VHJhbnNsYXRpb24nXG5pbXBvcnQgdXNlSW50ZXJzZWN0IGZyb20gJy4uLy4uLy4uL2hvb2tzL3VzZUludGVyc2VjdCdcbmltcG9ydCB7IHVzZU9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9PcGVyYXRpb25Qcm92aWRlcidcbmltcG9ydCBSZW5kZXJDdXN0b21Db21wb25lbnQgZnJvbSAnLi4vLi4vdXRpbGl0aWVzL1JlbmRlckN1c3RvbUNvbXBvbmVudCdcbmltcG9ydCB7IGZpbHRlckZpZWxkcyB9IGZyb20gJy4vZmlsdGVyRmllbGRzJ1xuaW1wb3J0ICcuL2luZGV4LnNjc3MnXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICdyZW5kZXItZmllbGRzJ1xuXG5jb25zdCBpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMgPSB7XG4gIHJvb3RNYXJnaW46ICcxMDAwcHgnLFxufVxuXG4vKipcbiAqIElmIHlvdSBzZW5kIGBmaWVsZHNgIHRocm91Z2gsIGl0IHdpbGwgcmVuZGVyIHRob3NlIGZpZWxkcyBleHBsaWNpdGx5XG4gKiBPdGhlcndpc2UsIGl0IHdpbGwgcmVkdWNlIHlvdXIgZmllbGRzIHVzaW5nIHRoZSBvdGhlciBwcm92aWRlZCBwcm9wc1xuICogVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBjb25kaXRpb25hbGx5IHJlbmRlciBmaWVsZHMgYmVmb3JlIHJlZHVjaW5nIHRoZW0sIGlmIGRlc2lyZWRcbiAqIFNlZSB0aGUgc2lkZWJhciBpbiAnLi4vY29sbGVjdGlvbnMvRWRpdC9EZWZhdWx0L2luZGV4LnRzeCcgZm9yIGFuIGV4YW1wbGVcbiAqXG4gKiBUaGUgc3RhdGUvZGF0YSBmb3IgdGhlIGZpZWxkcyBpdCByZW5kZXJzIGlzIG5vdCBtYW5hZ2VkIGJ5IHRoaXMgY29tcG9uZW50LiBJbnN0ZWFkLCBldmVyeSBjb21wb25lbnQgaXQgcmVuZGVycyBoYXNcbiAqIHRoZWlyIG93biBoYW5kbGluZyBvZiB0aGVpciBvd24gdmFsdWUsIHVzdWFsbHkgdGhyb3VnaCB0aGUgdXNlRmllbGQgaG9vay4gVGhpcyBob29rIHdpbGwgZ2V0IHRoZSBmaWVsZCdzIHZhbHVlXG4gKiBmcm9tIHRoZSBGb3JtIHRoZSBmaWVsZCBpcyBpbiwgdXNpbmcgdGhlIGZpZWxkJ3MgcGF0aC5cbiAqXG4gKiBUaHVzLCBpZiB5b3Ugd291bGQgbGlrZSB0byBzZXQgdGhlIHZhbHVlIG9mIGEgZmllbGQgeW91IHJlbmRlciBoZXJlLCB5b3UgbXVzdCBkbyBzbyBpbiB0aGUgRm9ybSB0aGF0IGNvbnRhaW5zIHRoZSBmaWVsZCwgb3IgaW4gdGhlXG4gKiBGaWVsZCBjb21wb25lbnQgaXRzZWxmLlxuICpcbiAqIEFsbCB0aGlzIGNvbXBvbmVudCBkb2VzIGlzIHJlbmRlciB0aGUgZmllbGQncyBGaWVsZCBDb21wb25lbnRzLCBhbmQgcGFzcyB0aGVtIHRoZSBwcm9wcyB0aGV5IG5lZWQgdG8gZnVuY3Rpb24uXG4gKiovXG5jb25zdCBSZW5kZXJGaWVsZHM6IFJlYWN0LkZDPFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgZmllbGRUeXBlcywgZm9yY2VSZW5kZXIsIG1hcmdpbnMgfSA9IHByb3BzXG5cbiAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VUcmFuc2xhdGlvbignZ2VuZXJhbCcpXG4gIGNvbnN0IFtoYXNSZW5kZXJlZCwgc2V0SGFzUmVuZGVyZWRdID0gdXNlU3RhdGUoQm9vbGVhbihmb3JjZVJlbmRlcikpXG4gIGNvbnN0IFtpbnRlcnNlY3Rpb25SZWYsIGVudHJ5XSA9IHVzZUludGVyc2VjdChpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMsIGZvcmNlUmVuZGVyKVxuXG4gIGNvbnN0IGlzSW50ZXJzZWN0aW5nID0gQm9vbGVhbihlbnRyeT8uaXNJbnRlcnNlY3RpbmcpXG4gIGNvbnN0IGlzQWJvdmVWaWV3cG9ydCA9IGVudHJ5Py5ib3VuZGluZ0NsaWVudFJlY3Q/LnRvcCA8IDBcbiAgY29uc3Qgc2hvdWxkUmVuZGVyID0gZm9yY2VSZW5kZXIgfHwgaXNJbnRlcnNlY3RpbmcgfHwgaXNBYm92ZVZpZXdwb3J0XG4gIGNvbnN0IG9wZXJhdGlvbiA9IHVzZU9wZXJhdGlvbigpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkUmVuZGVyICYmICFoYXNSZW5kZXJlZCkge1xuICAgICAgc2V0SGFzUmVuZGVyZWQodHJ1ZSlcbiAgICB9XG4gIH0sIFtzaG91bGRSZW5kZXIsIGhhc1JlbmRlcmVkXSlcblxuICBsZXQgZmllbGRzVG9SZW5kZXIgPSAnZmllbGRzJyBpbiBwcm9wcyA/IHByb3BzPy5maWVsZHMgOiBudWxsXG5cbiAgaWYgKCFmaWVsZHNUb1JlbmRlciAmJiAnZmllbGRTY2hlbWEnIGluIHByb3BzKSB7XG4gICAgY29uc3QgeyBmaWVsZFNjaGVtYSwgZmllbGRUeXBlcywgZmlsdGVyLCBwZXJtaXNzaW9ucywgcmVhZE9ubHk6IHJlYWRPbmx5T3ZlcnJpZGUgfSA9IHByb3BzXG5cbiAgICBmaWVsZHNUb1JlbmRlciA9IGZpbHRlckZpZWxkcyh7XG4gICAgICBmaWVsZFNjaGVtYSxcbiAgICAgIGZpZWxkVHlwZXMsXG4gICAgICBmaWx0ZXIsXG4gICAgICBvcGVyYXRpb24sXG4gICAgICBwZXJtaXNzaW9ucyxcbiAgICAgIHJlYWRPbmx5OiByZWFkT25seU92ZXJyaWRlLFxuICAgIH0pXG4gIH1cblxuICBpZiAoZmllbGRzVG9SZW5kZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICBiYXNlQ2xhc3MsXG4gICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgIG1hcmdpbnMgJiYgYCR7YmFzZUNsYXNzfS0tbWFyZ2lucy0ke21hcmdpbnN9YCxcbiAgICAgICAgICBtYXJnaW5zID09PSBmYWxzZSAmJiBgJHtiYXNlQ2xhc3N9LS1tYXJnaW5zLW5vbmVgLFxuICAgICAgICBdXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgIHJlZj17aW50ZXJzZWN0aW9uUmVmfVxuICAgICAgPlxuICAgICAgICB7aGFzUmVuZGVyZWQgJiZcbiAgICAgICAgICBmaWVsZHNUb1JlbmRlci5tYXAoKHJlZHVjZWRGaWVsZCwgZmllbGRJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBGaWVsZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgIGZpZWxkSXNQcmVzZW50YXRpb25hbCxcbiAgICAgICAgICAgICAgZmllbGRQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgaXNGaWVsZEFmZmVjdGluZ0RhdGEsXG4gICAgICAgICAgICAgIHJlYWRPbmx5LFxuICAgICAgICAgICAgfSA9IHJlZHVjZWRGaWVsZFxuXG4gICAgICAgICAgICBpZiAoZmllbGRJc1ByZXNlbnRhdGlvbmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiA8RmllbGRDb21wb25lbnQga2V5PXtmaWVsZEluZGV4fSB7Li4uZmllbGR9IC8+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxSZW5kZXJDdXN0b21Db21wb25lbnRcbiAgICAgICAgICAgICAgICAgIEN1c3RvbUNvbXBvbmVudD17ZmllbGQ/LmFkbWluPy5jb21wb25lbnRzPy5GaWVsZH1cbiAgICAgICAgICAgICAgICAgIERlZmF1bHRDb21wb25lbnQ9e0ZpZWxkQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHM9e3tcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGFkbWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uKGZpZWxkLmFkbWluIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4UGF0aDpcbiAgICAgICAgICAgICAgICAgICAgICAnaW5kZXhQYXRoJyBpbiBwcm9wcyA/IGAke3Byb3BzPy5pbmRleFBhdGh9LiR7ZmllbGRJbmRleH1gIDogYCR7ZmllbGRJbmRleH1gLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmaWVsZC5wYXRoIHx8IChpc0ZpZWxkQWZmZWN0aW5nRGF0YSAmJiAnbmFtZScgaW4gZmllbGQgPyBmaWVsZC5uYW1lIDogJycpLFxuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogZmllbGRQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICBrZXk9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pc3NpbmctZmllbGRcIiBrZXk9e2ZpZWxkSW5kZXh9PlxuICAgICAgICAgICAgICAgIHt0KCdlcnJvcjpub01hdGNoZWRGaWVsZCcsIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsOiBmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKVxuICAgICAgICAgICAgICAgICAgICA/IGdldFRyYW5zbGF0aW9uKGZpZWxkLmxhYmVsIHx8IGZpZWxkLm5hbWUsIGkxOG4pXG4gICAgICAgICAgICAgICAgICAgIDogZmllbGQucGF0aCxcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJGaWVsZHNcbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMiLCJyb290TWFyZ2luIiwiUmVuZGVyRmllbGRzIiwicHJvcHMiLCJjbGFzc05hbWUiLCJmaWVsZFR5cGVzIiwiZm9yY2VSZW5kZXIiLCJtYXJnaW5zIiwiaTE4biIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsImhhc1JlbmRlcmVkIiwic2V0SGFzUmVuZGVyZWQiLCJ1c2VTdGF0ZSIsIkJvb2xlYW4iLCJpbnRlcnNlY3Rpb25SZWYiLCJlbnRyeSIsInVzZUludGVyc2VjdCIsImlzSW50ZXJzZWN0aW5nIiwiaXNBYm92ZVZpZXdwb3J0IiwiYm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwic2hvdWxkUmVuZGVyIiwib3BlcmF0aW9uIiwidXNlT3BlcmF0aW9uIiwidXNlRWZmZWN0IiwiZmllbGRzVG9SZW5kZXIiLCJmaWVsZHMiLCJmaWVsZFNjaGVtYSIsImZpbHRlciIsInBlcm1pc3Npb25zIiwicmVhZE9ubHkiLCJyZWFkT25seU92ZXJyaWRlIiwiZmlsdGVyRmllbGRzIiwiZGl2Iiwiam9pbiIsInJlZiIsIm1hcCIsInJlZHVjZWRGaWVsZCIsImZpZWxkSW5kZXgiLCJGaWVsZENvbXBvbmVudCIsImZpZWxkIiwiZmllbGRJc1ByZXNlbnRhdGlvbmFsIiwiZmllbGRQZXJtaXNzaW9ucyIsImlzRmllbGRBZmZlY3RpbmdEYXRhIiwia2V5IiwiUmVuZGVyQ3VzdG9tQ29tcG9uZW50IiwiQ3VzdG9tQ29tcG9uZW50IiwiYWRtaW4iLCJjb21wb25lbnRzIiwiRmllbGQiLCJEZWZhdWx0Q29tcG9uZW50IiwiY29tcG9uZW50UHJvcHMiLCJpbmRleFBhdGgiLCJwYXRoIiwibmFtZSIsImxhYmVsIiwiZmllbGRBZmZlY3RzRGF0YSIsImdldFRyYW5zbGF0aW9uIl0sInJhbmdlTWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiOzs7OytCQXVJQTs7O2VBQUE7OzsrREF2STJDOzhCQUNaO3VCQUlFO2dDQUNGO3FFQUNOO21DQUNJOzhFQUNLOzhCQUNMO1FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLE1BQU1BLFlBQVk7QUFFbEIsTUFBTUMsOEJBQThCO0lBQ2xDQyxZQUFZO0FBQ2Q7QUFFQTs7Ozs7Ozs7Ozs7Ozs7RUFjRSxHQUNGLE1BQU1DLGVBQWdDLENBQUNDO0lBQ3JDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxFQUFFLEdBQUdKO0lBRXhELE1BQU0sRUFBRUssSUFBSSxFQUFFQyxDQUFDLEVBQUUsR0FBR0MsSUFBQUEsNEJBQWMsRUFBQztJQUNuQyxNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBR0MsSUFBQUEsZUFBUSxFQUFDQyxRQUFRUjtJQUN2RCxNQUFNLENBQUNTLGlCQUFpQkMsTUFBTSxHQUFHQyxJQUFBQSxxQkFBWSxFQUFDakIsNkJBQTZCTTtJQUUzRSxNQUFNWSxpQkFBaUJKLFFBQVFFLE9BQU9FO0lBQ3RDLE1BQU1DLGtCQUFrQkgsT0FBT0ksb0JBQW9CQyxNQUFNO0lBQ3pELE1BQU1DLGVBQWVoQixlQUFlWSxrQkFBa0JDO0lBQ3RELE1BQU1JLFlBQVlDLElBQUFBLCtCQUFZO0lBRTlCQyxJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsSUFBSUgsZ0JBQWdCLENBQUNYLGFBQWE7WUFDaENDLGVBQWU7UUFDakI7SUFDRixHQUFHO1FBQUNVO1FBQWNYO0tBQVk7SUFFOUIsSUFBSWUsaUJBQWlCLFlBQVl2QixRQUFRQSxPQUFPd0IsU0FBUztJQUV6RCxJQUFJLENBQUNELGtCQUFrQixpQkFBaUJ2QixPQUFPO1FBQzdDLE1BQU0sRUFBRXlCLFdBQVcsRUFBRXZCLFVBQVUsRUFBRXdCLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxVQUFVQyxnQkFBZ0IsRUFBRSxHQUFHN0I7UUFFckZ1QixpQkFBaUJPLElBQUFBLDBCQUFZLEVBQUM7WUFDNUJMO1lBQ0F2QjtZQUNBd0I7WUFDQU47WUFDQU87WUFDQUMsVUFBVUM7UUFDWjtJQUNGO0lBRUEsSUFBSU4sZ0JBQWdCO1FBQ2xCLHFCQUNFLDZCQUFDUTtZQUNDOUIsV0FBVztnQkFDVEw7Z0JBQ0FLO2dCQUNBRyxXQUFXLENBQUMsRUFBRVIsVUFBVSxVQUFVLEVBQUVRLFFBQVEsQ0FBQztnQkFDN0NBLFlBQVksU0FBUyxDQUFDLEVBQUVSLFVBQVUsY0FBYyxDQUFDO2FBQ2xELENBQ0U4QixNQUFNLENBQUNmLFNBQ1BxQixJQUFJLENBQUM7WUFDUkMsS0FBS3JCO1dBRUpKLGVBQ0NlLGVBQWVXLEdBQUcsQ0FBQyxDQUFDQyxjQUFjQztZQUNoQyxNQUFNLEVBQ0pDLGNBQWMsRUFDZEMsS0FBSyxFQUNMQyxxQkFBcUIsRUFDckJDLGdCQUFnQixFQUNoQkMsb0JBQW9CLEVBQ3BCYixRQUFRLEVBQ1QsR0FBR087WUFFSixJQUFJSSx1QkFBdUI7Z0JBQ3pCLHFCQUFPLDZCQUFDRjtvQkFBZUssS0FBS047b0JBQWEsR0FBR0UsS0FBSzs7WUFDbkQ7WUFFQSxJQUFJQSxPQUFPO2dCQUNULHFCQUNFLDZCQUFDSyw4QkFBcUI7b0JBQ3BCQyxpQkFBaUJOLE9BQU9PLE9BQU9DLFlBQVlDO29CQUMzQ0Msa0JBQWtCWDtvQkFDbEJZLGdCQUFnQjt3QkFDZCxHQUFHWCxLQUFLO3dCQUNSTyxPQUFPOzRCQUNMLEdBQUlQLE1BQU1PLEtBQUssSUFBSSxDQUFDLENBQUM7NEJBQ3JCakI7d0JBQ0Y7d0JBQ0ExQjt3QkFDQUM7d0JBQ0ErQyxXQUNFLGVBQWVsRCxRQUFRLENBQUMsRUFBRUEsT0FBT2tELFVBQVUsQ0FBQyxFQUFFZCxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUVBLFdBQVcsQ0FBQzt3QkFDOUVlLE1BQU1iLE1BQU1hLElBQUksSUFBS1YsQ0FBQUEsd0JBQXdCLFVBQVVILFFBQVFBLE1BQU1jLElBQUksR0FBRyxFQUFDO3dCQUM3RXpCLGFBQWFhO29CQUNmO29CQUNBRSxLQUFLTjs7WUFHWDtZQUVBLHFCQUNFLDZCQUFDTDtnQkFBSTlCLFdBQVU7Z0JBQWdCeUMsS0FBS047ZUFDakM5QixFQUFFLHdCQUF3QjtnQkFDekIrQyxPQUFPQyxJQUFBQSx1QkFBZ0IsRUFBQ2hCLFNBQ3BCaUIsSUFBQUEsOEJBQWMsRUFBQ2pCLE1BQU1lLEtBQUssSUFBSWYsTUFBTWMsSUFBSSxFQUFFL0MsUUFDMUNpQyxNQUFNYSxJQUFJO1lBQ2hCO1FBR047SUFHUjtJQUVBLE9BQU87QUFDVDtNQUVBLFdBQWVwRCJ9